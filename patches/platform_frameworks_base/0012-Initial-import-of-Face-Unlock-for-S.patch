From 128d7ec4598053ad765013ab553cee3e13e247f3 Mon Sep 17 00:00:00 2001
From: jhenrique09 <jhsv09@gmail.com>
Date: Wed, 9 Feb 2022 22:16:43 -0300
Subject: [PATCH 12/24] Initial import of Face Unlock for S

Change-Id: If784cd1283dade71e72995e828586e3be2b4abb0
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 packages/SystemUI/Android.bp                  |   1 +
 services/core/Android.bp                      |   1 +
 .../biometrics/sensors/face/FaceService.java  |   8 +
 .../sensors/face/custom/ArrayUtils.java       |  65 ++
 .../face/custom/BiometricTestSessionImpl.java | 164 ++++
 .../face/custom/CustomFaceProvider.java       | 834 ++++++++++++++++++
 .../face/custom/FaceAuthenticationClient.java | 138 +++
 .../sensors/face/custom/FaceEnrollClient.java |  99 +++
 .../custom/FaceGenerateChallengeClient.java   |  91 ++
 .../face/custom/FaceGetFeatureClient.java     |  83 ++
 .../custom/FaceInternalCleanupClient.java     |  47 +
 .../custom/FaceInternalEnumerateClient.java   |  48 +
 .../face/custom/FaceRemovalClient.java        |  51 ++
 .../face/custom/FaceResetLockoutClient.java   |  61 ++
 .../custom/FaceRevokeChallengeClient.java     |  45 +
 .../face/custom/FaceSetFeatureClient.java     |  75 ++
 .../custom/FaceUpdateActiveUserClient.java    |  72 ++
 .../sensors/face/custom/TestHal.java          | 128 +++
 .../policy/PermissionPolicyService.java       |   8 +
 19 files changed, 2019 insertions(+)
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java
 create mode 100644 services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java

diff --git a/packages/SystemUI/Android.bp b/packages/SystemUI/Android.bp
index 75e1b666d279..d3c0b4160286 100644
--- a/packages/SystemUI/Android.bp
+++ b/packages/SystemUI/Android.bp
@@ -98,6 +98,7 @@ android_library {
         "tensorflowlite_java",
         "colorkt",
         "themelib",
+        "faceunlock_framework",
     ],
     manifest: "AndroidManifest.xml",
 
diff --git a/services/core/Android.bp b/services/core/Android.bp
index f5280fa1adde..0827b1943051 100644
--- a/services/core/Android.bp
+++ b/services/core/Android.bp
@@ -167,6 +167,7 @@ java_library_static {
         "kotlin-stdlib",
         "kotlinx-coroutines-android",
         "kotlinx-coroutines-core",
+        "faceunlock_framework",
     ],
     javac_shard_size: 50,
 }
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java b/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
index 675ee545a14f..a92fab6ad4c5 100644
--- a/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
+++ b/services/core/java/com/android/server/biometrics/sensors/face/FaceService.java
@@ -61,6 +61,7 @@ import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
 import com.android.server.biometrics.sensors.LockoutResetDispatcher;
 import com.android.server.biometrics.sensors.LockoutTracker;
 import com.android.server.biometrics.sensors.face.aidl.FaceProvider;
+import com.android.server.biometrics.sensors.face.custom.CustomFaceProvider;
 import com.android.server.biometrics.sensors.face.hidl.Face10;
 
 import java.io.FileDescriptor;
@@ -652,6 +653,12 @@ public class FaceService extends SystemService {
             }
         }
 
+        private void addCustomProviders() {
+            if (CustomFaceProvider.useCustomFaceUnlockService()) {
+                mServiceProviders.add(new CustomFaceProvider(getContext(), new FaceSensorPropertiesInternal(CustomFaceProvider.DEVICE_ID, 0, 1, new ArrayList(), 1, false, false, false), mLockoutResetDispatcher));
+            }
+        }
+
         @Override // Binder call
         public void registerAuthenticators(
                 @NonNull List<FaceSensorPropertiesInternal> hidlSensors) {
@@ -669,6 +676,7 @@ public class FaceService extends SystemService {
             handler.post(() -> {
                 addHidlProviders(hidlSensors);
                 addAidlProviders();
+                addCustomProviders();
 
                 final IBiometricService biometricService = IBiometricService.Stub.asInterface(
                         ServiceManager.getService(Context.BIOMETRIC_SERVICE));
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java
new file mode 100644
index 000000000000..617781c0a08f
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/ArrayUtils.java
@@ -0,0 +1,65 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import java.util.ArrayList;
+
+public class ArrayUtils {
+    public static ArrayList<Byte> toByteArrayList(byte[] in) {
+        if (in == null) {
+            return null;
+        }
+        ArrayList<Byte> out = new ArrayList<>(in.length);
+        for (byte c : in) {
+            out.add(c);
+        }
+        return out;
+    }
+
+    public static ArrayList<Integer> toIntArrayList(int[] in) {
+        if (in == null) {
+            return null;
+        }
+        ArrayList<Integer> out = new ArrayList<>(in.length);
+        for (int c : in) {
+            out.add(c);
+        }
+        return out;
+    }
+
+    public static int[] toIntArray(ArrayList<Integer> in) {
+        if (in == null) {
+            return null;
+        }
+        int[] out = new int[in.size()];
+        for (int i = 0; i < in.size(); i++) {
+            out[i] = in.get(i);
+        }
+        return out;
+    }
+
+    public static byte[] toByteArray(ArrayList<Byte> in) {
+        if (in == null) {
+            return null;
+        }
+        byte[] out = new byte[in.size()];
+        for (int i = 0; i < in.size(); i++) {
+            out[i] = in.get(i);
+        }
+        return out;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java
new file mode 100644
index 000000000000..a7b381ecf49d
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/BiometricTestSessionImpl.java
@@ -0,0 +1,164 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.biometrics.ITestSession;
+import android.hardware.biometrics.ITestSessionCallback;
+import android.hardware.face.Face;
+import android.hardware.face.FaceAuthenticationFrame;
+import android.hardware.face.FaceEnrollFrame;
+import android.hardware.face.IFaceServiceReceiver;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.server.biometrics.Utils;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.face.FaceUtils;
+
+import java.util.List;
+import java.util.Random;
+
+public class BiometricTestSessionImpl extends ITestSession.Stub {
+    private static final String TAG = "BiometricTestSessionImpl";
+    private final ITestSessionCallback mCallback;
+    private final Context mContext;
+    private final CustomFaceProvider.HalResultController mHalResultController;
+    private final CustomFaceProvider mCustomFaceProvider;
+    private final int mSensorId;
+    private final IFaceServiceReceiver mReceiver = new IFaceServiceReceiver.Stub() {
+        @Override
+        public void onEnrollResult(Face face, int remaining) {
+        }
+
+        @Override
+        public void onAcquired(int acquiredInfo, int vendorCode) {
+        }
+
+        @Override
+        public void onAuthenticationSucceeded(Face face, int userId, boolean isStrongBiometric) {
+        }
+
+        @Override
+        public void onFaceDetected(int sensorId, int userId, boolean isStrongBiometric) {
+        }
+
+        @Override
+        public void onAuthenticationFailed() {
+        }
+
+        @Override
+        public void onError(int error, int vendorCode) {
+        }
+
+        @Override
+        public void onRemoved(Face face, int remaining) {
+        }
+
+        @Override
+        public void onFeatureSet(boolean success, int feature) {
+        }
+
+        @Override
+        public void onFeatureGet(boolean success, int[] features, boolean[] featureState) {
+        }
+
+        public void onChallengeGenerated(int sensorId, int userId, long challenge) {
+        }
+
+        @Override
+        public void onAuthenticationFrame(FaceAuthenticationFrame frame) {
+        }
+
+        @Override
+        public void onEnrollmentFrame(FaceEnrollFrame frame) {
+        }
+    };
+    private final Random mRandom = new Random();
+
+    public BiometricTestSessionImpl(Context context, int sensorId, ITestSessionCallback callback, CustomFaceProvider customFaceProvider, CustomFaceProvider.HalResultController halResultController) {
+        mContext = context;
+        mSensorId = sensorId;
+        mCallback = callback;
+        mCustomFaceProvider = customFaceProvider;
+        mHalResultController = halResultController;
+    }
+
+    public void setTestHalEnabled(boolean enabled) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mCustomFaceProvider.setTestHalEnabled(enabled);
+    }
+
+    public void startEnroll(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mCustomFaceProvider.scheduleEnroll(mSensorId, new Binder(), new byte[69], userId, mReceiver, mContext.getOpPackageName(), new int[0], null, false);
+    }
+
+    public void finishEnroll(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mHalResultController.onEnrollResult(1, userId, 0);
+    }
+
+    public void acceptAuthentication(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        List<Face> faces = FaceUtils.getLegacyInstance(mSensorId).getBiometricsForUser(mContext, userId);
+        if (faces.isEmpty()) {
+            Slog.w(TAG, "No faces, returning");
+        } else {
+            mHalResultController.onAuthenticated(faces.get(0).getBiometricId(), userId, new byte[]{0});
+        }
+    }
+
+    public void rejectAuthentication(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mHalResultController.onAuthenticated(0, userId, null);
+    }
+
+    public void notifyAcquired(int userId, int acquireInfo) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mHalResultController.onAcquired(userId, acquireInfo, 0);
+    }
+
+    public void notifyError(int userId, int errorCode) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mHalResultController.onError(errorCode, 0);
+    }
+
+    public void cleanupInternalState(int userId) {
+        Utils.checkPermission(mContext, "android.permission.TEST_BIOMETRIC");
+        mCustomFaceProvider.scheduleInternalCleanup(mSensorId, userId, new BaseClientMonitor.Callback() {
+            @Override
+            public void onClientStarted(BaseClientMonitor clientMonitor) {
+                try {
+                    mCallback.onCleanupStarted(clientMonitor.getTargetUserId());
+                } catch (RemoteException e) {
+                    Slog.e(BiometricTestSessionImpl.TAG, "Remote exception", e);
+                }
+            }
+
+            @Override
+            public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                try {
+                    mCallback.onCleanupFinished(clientMonitor.getTargetUserId());
+                } catch (RemoteException e) {
+                    Slog.e(BiometricTestSessionImpl.TAG, "Remote exception", e);
+                }
+            }
+        });
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java
new file mode 100644
index 000000000000..db5abc264723
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/CustomFaceProvider.java
@@ -0,0 +1,834 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.app.ActivityManager;
+import android.app.SynchronousUserSwitchObserver;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ServiceConnection;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.pm.UserInfo;
+import android.hardware.biometrics.IInvalidationCallback;
+import android.hardware.biometrics.ITestSession;
+import android.hardware.biometrics.ITestSessionCallback;
+import android.hardware.face.Face;
+import android.hardware.face.FaceSensorPropertiesInternal;
+import android.hardware.face.IFaceServiceReceiver;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.RemoteException;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.provider.Settings;
+import android.util.Slog;
+import android.util.SparseArray;
+import android.util.proto.ProtoOutputStream;
+import android.view.Surface;
+
+import android.annotation.NonNull;
+
+import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.SensorServiceStateProto;
+import com.android.server.biometrics.SensorStateProto;
+import com.android.server.biometrics.UserStateProto;
+import com.android.server.biometrics.Utils;
+import com.android.server.biometrics.sensors.AcquisitionClient;
+import com.android.server.biometrics.sensors.AuthenticationConsumer;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.BiometricNotificationUtils;
+import com.android.server.biometrics.sensors.BiometricScheduler;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.EnumerateConsumer;
+import com.android.server.biometrics.sensors.ErrorConsumer;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.sensors.LockoutResetDispatcher;
+import com.android.server.biometrics.sensors.PerformanceTracker;
+import com.android.server.biometrics.sensors.RemovalConsumer;
+import com.android.server.biometrics.sensors.face.FaceUtils;
+import com.android.server.biometrics.sensors.face.LockoutHalImpl;
+import com.android.server.biometrics.sensors.face.ServiceProvider;
+import com.android.server.biometrics.sensors.face.UsageStats;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.time.Clock;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+
+public class CustomFaceProvider implements ServiceProvider {
+    public static final int DEVICE_ID = 1008;
+    private static final int ENROLL_TIMEOUT_SEC = 75;
+    private static final int GENERATE_CHALLENGE_COUNTER_TTL_MILLIS = 600000;
+    private static final int GENERATE_CHALLENGE_REUSE_INTERVAL_MILLIS = 60000;
+    private static final String TAG = CustomFaceProvider.class.getSimpleName();
+    public static Clock sSystemClock = Clock.systemUTC();
+    final SparseArray<IFaceService> mFaceServices;
+    private final Map<Integer, Long> mAuthenticatorIds;
+    private final Context mContext;
+    private final List<Long> mGeneratedChallengeCount;
+    private final HalResultController mHalResultController;
+    private final Handler mHandler;
+    private final HalClientMonitor.LazyDaemon<IFaceService> mLazyDaemon;
+    private final LockoutHalImpl mLockoutTracker;
+    private final BiometricScheduler mScheduler;
+    private final int mSensorId;
+    private final FaceSensorPropertiesInternal mSensorProperties;
+    private final UsageStats mUsageStats;
+    @NonNull
+    private final AtomicLong mRequestCounter = new AtomicLong(0);
+    private int mCurrentUserId;
+    private FaceGenerateChallengeClient mGeneratedChallengeCache;
+    private boolean mIsServiceBinding;
+    private TestHal mTestHal;
+    private boolean mTestHalEnabled;
+
+    CustomFaceProvider(Context context, FaceSensorPropertiesInternal sensorProps, LockoutResetDispatcher lockoutResetDispatcher, BiometricScheduler scheduler) {
+        mTestHalEnabled = false;
+        mCurrentUserId = -10000;
+        mGeneratedChallengeCount = new ArrayList<>();
+        mGeneratedChallengeCache = null;
+        mFaceServices = new SparseArray<>();
+        mIsServiceBinding = false;
+        mSensorProperties = sensorProps;
+        mContext = context;
+        mSensorId = sensorProps.sensorId;
+        mScheduler = scheduler;
+        Handler handler = new Handler(Looper.getMainLooper());
+        mHandler = handler;
+        mUsageStats = new UsageStats(context);
+        mAuthenticatorIds = new HashMap<>();
+        mLazyDaemon = CustomFaceProvider.this::getDaemon;
+        LockoutHalImpl lockoutHalImpl = new LockoutHalImpl();
+        mLockoutTracker = lockoutHalImpl;
+        HalResultController halResultController = new HalResultController(sensorProps.sensorId, context, handler, scheduler, lockoutHalImpl, lockoutResetDispatcher);
+        mHalResultController = halResultController;
+        halResultController.setCallback(() -> {
+            mCurrentUserId = -10000;
+        });
+        mCurrentUserId = ActivityManager.getCurrentUser();
+        try {
+            ActivityManager.getService().registerUserSwitchObserver(new SynchronousUserSwitchObserver() {
+                public void onUserSwitching(int newUserId) {
+                    Slog.d(TAG, "user switch : newUserId = " + newUserId);
+                    mCurrentUserId = newUserId;
+                    if (getDaemon() == null) {
+                        bindFaceAuthService(mCurrentUserId);
+                    }
+                }
+            }, TAG);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to register user switch observer");
+        }
+        context.registerReceiver(new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context2, Intent intent) {
+                if (getDaemon() == null) {
+                    bindFaceAuthService(mCurrentUserId);
+                }
+            }
+        }, new IntentFilter("android.intent.action.USER_UNLOCKED"));
+    }
+
+    public CustomFaceProvider(Context context, FaceSensorPropertiesInternal sensorProps, LockoutResetDispatcher lockoutResetDispatcher) {
+        this(context, sensorProps, lockoutResetDispatcher, new BiometricScheduler(TAG, 0, null));
+    }
+
+    synchronized IFaceService getDaemon() {
+        if (mTestHalEnabled) {
+            if (mTestHal == null) {
+                mTestHal = new TestHal(mCurrentUserId, mContext, mSensorId);
+            }
+            try {
+                mTestHal.setCallback(mHalResultController);
+            } catch (RemoteException e) {
+                e.printStackTrace();
+            }
+            return mTestHal;
+        }
+        IFaceService service = getFaceService(mCurrentUserId);
+        if (service == null) {
+            bindFaceAuthService(mCurrentUserId);
+        }
+        return service;
+    }
+
+    @Override
+    public boolean containsSensor(int sensorId) {
+        return mSensorId == sensorId;
+    }
+
+    @Override
+    public List<FaceSensorPropertiesInternal> getSensorProperties() {
+        List<FaceSensorPropertiesInternal> properties = new ArrayList<>();
+        properties.add(mSensorProperties);
+        return properties;
+    }
+
+    @Override
+    public FaceSensorPropertiesInternal getSensorProperties(int sensorId) {
+        return mSensorProperties;
+    }
+
+    @Override
+    public List<Face> getEnrolledFaces(int sensorId, int userId) {
+        return FaceUtils.getLegacyInstance(mSensorId).getBiometricsForUser(mContext, userId);
+    }
+
+    @Override
+    public int getLockoutModeForUser(int sensorId, int userId) {
+        return mLockoutTracker.getLockoutModeForUser(userId);
+    }
+
+    @Override
+    public long getAuthenticatorId(int sensorId, int userId) {
+        return mAuthenticatorIds.getOrDefault(Integer.valueOf(userId), 0L).longValue();
+    }
+
+    @Override
+    public boolean isHardwareDetected(int sensorId) {
+        return getDaemon() != null;
+    }
+
+    private boolean isGeneratedChallengeCacheValid() {
+        return mGeneratedChallengeCache != null && sSystemClock.millis() - mGeneratedChallengeCache.getCreatedAt() < GENERATE_CHALLENGE_REUSE_INTERVAL_MILLIS;
+    }
+
+    private void incrementChallengeCount() {
+        mGeneratedChallengeCount.add(0, sSystemClock.millis());
+    }
+
+    private int decrementChallengeCount() {
+        mGeneratedChallengeCount.removeIf(aLong -> sSystemClock.millis() - aLong > GENERATE_CHALLENGE_COUNTER_TTL_MILLIS);
+        if (!mGeneratedChallengeCount.isEmpty()) {
+            mGeneratedChallengeCount.remove(0);
+        }
+        return mGeneratedChallengeCount.size();
+    }
+
+    @Override
+    public void scheduleGenerateChallenge(int sensorId, int userId, IBinder token, IFaceServiceReceiver receiver, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onChallengeGenerated(sensorId, userId, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                incrementChallengeCount();
+                if (isGeneratedChallengeCacheValid()) {
+                    Slog.d(TAG, "Current challenge is cached and will be reused");
+                    mGeneratedChallengeCache.reuseResult(receiver);
+                    return;
+                }
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                final FaceGenerateChallengeClient client = new FaceGenerateChallengeClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId, opPackageName, mSensorId, sSystemClock.millis());
+                mGeneratedChallengeCache = client;
+                mScheduler.scheduleClientMonitor(client, new BaseClientMonitor.Callback() {
+                    @Override
+                    public void onClientStarted(BaseClientMonitor clientMonitor) {
+                        if (client != clientMonitor) {
+                            Slog.e(TAG, "scheduleGenerateChallenge onClientStarted, mismatched client. Expecting: " + client + ", received: " + clientMonitor);
+                        }
+                    }
+                });
+            }
+        });
+    }
+
+    @Override
+    public void scheduleRevokeChallenge(int sensorId, int userId, IBinder token, String opPackageName, long challenge) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                return;
+            }
+            if (!(decrementChallengeCount() == 0)) {
+                Slog.w(TAG, "scheduleRevokeChallenge skipped - challenge still in use: " + mGeneratedChallengeCount);
+                return;
+            }
+            Slog.d(TAG, "scheduleRevokeChallenge executing - no active clients");
+            mGeneratedChallengeCache = null;
+            final FaceRevokeChallengeClient client = new FaceRevokeChallengeClient(mContext, mLazyDaemon, token, userId, opPackageName, mSensorId);
+            mScheduler.scheduleClientMonitor(client, new BaseClientMonitor.Callback() {
+                @Override
+                public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                    if (client != clientMonitor) {
+                        Slog.e(TAG, "scheduleRevokeChallenge, mismatched client.Expecting: " + client + ", received: " + clientMonitor);
+                    }
+                }
+            });
+        });
+    }
+
+    @Override
+    public void scheduleEnroll(int sensorId, IBinder token, byte[] hardwareAuthToken, int userId, IFaceServiceReceiver receiver, String opPackageName, int[] disabledFeatures, Surface previewSurface, boolean debugConsent) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onError(2, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                BiometricNotificationUtils.cancelReEnrollNotification(mContext);
+                final FaceEnrollClient client = new FaceEnrollClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId, hardwareAuthToken, opPackageName, FaceUtils.getLegacyInstance(mSensorId), disabledFeatures, ENROLL_TIMEOUT_SEC, previewSurface, mSensorId);
+                mScheduler.scheduleClientMonitor(client, new BaseClientMonitor.Callback() {
+                    @Override
+                    public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                        if (success) {
+                            scheduleUpdateActiveUserWithoutHandler(client.getTargetUserId());
+                        }
+                    }
+                });
+            }
+        });
+    }
+
+    @Override
+    public void cancelEnrollment(int sensorId, IBinder token) {
+        mHandler.post(() -> mScheduler.cancelEnrollment(token));
+    }
+
+    @Override
+    public long scheduleFaceDetect(int sensorId, IBinder token, int userId, ClientMonitorCallbackConverter callback, String opPackageName, int statsClient) {
+        throw new IllegalStateException("Face detect not supported by IBiometricsFace@1.0. Did youforget to check the supportsFaceDetection flag?");
+    }
+
+    @Override
+    public void cancelFaceDetect(int sensorId, IBinder token, long requestId) {
+        throw new IllegalStateException("Face detect not supported by IBiometricsFace@1.0. Did youforget to check the supportsFaceDetection flag?");
+    }
+
+    @Override
+    public long scheduleAuthenticate(int sensorId, IBinder token, long operationId,
+                                     int userId, int cookie, ClientMonitorCallbackConverter receiver,
+                                     String opPackageName, boolean restricted, int statsClient,
+                                     boolean allowBackgroundAuthentication, boolean isKeyguardBypassEnabled) {
+        final long id = mRequestCounter.incrementAndGet();
+        scheduleAuthenticate(sensorId, token, operationId, userId, cookie, receiver,
+                opPackageName, id, restricted, statsClient,
+                allowBackgroundAuthentication, isKeyguardBypassEnabled);
+        return id;
+    }
+
+    @Override
+    public void scheduleAuthenticate(int sensorId, IBinder token, long operationId, int userId, int cookie, ClientMonitorCallbackConverter receiver, String opPackageName, long requestId, boolean restricted, int statsClient, boolean allowBackgroundAuthentication, boolean isKeyguardBypassEnabled) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onError(DEVICE_ID, 0, 1, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                mScheduler.scheduleClientMonitor(new FaceAuthenticationClient(mContext, mLazyDaemon, token, receiver, userId, operationId, restricted, opPackageName, cookie, false, mSensorId, Utils.isStrongBiometric(mSensorId), statsClient, mLockoutTracker, mUsageStats, allowBackgroundAuthentication));
+            }
+        });
+    }
+
+    @Override
+    public void cancelAuthentication(int sensorId, IBinder token, long requestId) {
+        mHandler.post(() -> mScheduler.cancelAuthenticationOrDetection(token, sensorId));
+    }
+
+    @Override
+    public void scheduleRemove(int sensorId, IBinder token, int faceId, int userId, IFaceServiceReceiver receiver, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onError(1, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                mScheduler.scheduleClientMonitor(new FaceRemovalClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), faceId, userId, opPackageName, FaceUtils.getLegacyInstance(mSensorId), mSensorId, mAuthenticatorIds));
+            }
+        });
+    }
+
+    @Override
+    public void scheduleRemoveAll(int sensorId, IBinder token, int userId, IFaceServiceReceiver receiver, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                try {
+                    receiver.onError(1, 0);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                mScheduler.scheduleClientMonitor(new FaceRemovalClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), 0, userId, opPackageName, FaceUtils.getLegacyInstance(mSensorId), mSensorId, mAuthenticatorIds));
+            }
+        });
+    }
+
+    @Override
+    public void scheduleResetLockout(int sensorId, int userId, byte[] hardwareAuthToken) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+            } else if (getEnrolledFaces(sensorId, userId).isEmpty()) {
+                Slog.w(TAG, "Ignoring lockout reset, no templates enrolled for user: " + userId);
+            } else {
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                mScheduler.scheduleClientMonitor(new FaceResetLockoutClient(mContext, mLazyDaemon, userId, mContext.getOpPackageName(), mSensorId, hardwareAuthToken));
+            }
+        });
+    }
+
+    @Override
+    public void scheduleSetFeature(int sensorId, IBinder token, int userId, int feature, boolean enabled, byte[] hardwareAuthToken, IFaceServiceReceiver receiver, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                return;
+            }
+            List<Face> faces = getEnrolledFaces(sensorId, userId);
+            if (faces.isEmpty()) {
+                Slog.w(TAG, "Ignoring setFeature, no templates enrolled for user: " + userId);
+                return;
+            }
+            scheduleUpdateActiveUserWithoutHandler(userId);
+            mScheduler.scheduleClientMonitor(new FaceSetFeatureClient(mContext, mLazyDaemon, token, new ClientMonitorCallbackConverter(receiver), userId, opPackageName, mSensorId, feature, enabled, hardwareAuthToken, faces.get(0).getBiometricId()));
+        });
+    }
+
+    @Override
+    public void scheduleGetFeature(int sensorId, IBinder token, int userId, int feature, ClientMonitorCallbackConverter listener, String opPackageName) {
+        mHandler.post(() -> {
+            if (getDaemon() == null) {
+                bindFaceAuthService(mCurrentUserId);
+                if (listener != null) {
+                    try {
+                        listener.onError(DEVICE_ID, 0, 1, 0);
+                    } catch (RemoteException e) {
+                        e.printStackTrace();
+                    }
+                }
+            } else {
+                List<Face> faces = getEnrolledFaces(sensorId, userId);
+                if (faces.isEmpty()) {
+                    Slog.w(TAG, "Ignoring getFeature, no templates enrolled for user: " + userId);
+                    return;
+                }
+                scheduleUpdateActiveUserWithoutHandler(userId);
+                final FaceGetFeatureClient client = new FaceGetFeatureClient(mContext, mLazyDaemon, token, listener, userId, opPackageName, mSensorId, feature, faces.get(0).getBiometricId());
+                mScheduler.scheduleClientMonitor(client, new BaseClientMonitor.Callback() {
+                    @Override
+                    public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                        if (success && feature == 1) {
+                            final int settingsValue = client.getValue() ? 1 : 0;
+                            Slog.d(TAG, "Updating attention value for user: " + userId + " to value: " + settingsValue);
+                            Settings.Secure.putIntForUser(mContext.getContentResolver(), "face_unlock_attention_required", settingsValue, userId);
+                        }
+                    }
+                });
+            }
+        });
+    }
+
+    void scheduleInternalCleanup(int userId, BaseClientMonitor.Callback callback) {
+        mHandler.post(() -> {
+            scheduleUpdateActiveUserWithoutHandler(userId);
+            List<Face> enrolledList = getEnrolledFaces(mSensorId, userId);
+            String opPackageName = mContext.getOpPackageName();
+            mScheduler.scheduleClientMonitor(new FaceInternalCleanupClient(mContext, mLazyDaemon, userId, opPackageName, mSensorId, enrolledList, FaceUtils.getLegacyInstance(mSensorId), mAuthenticatorIds), callback);
+        });
+    }
+
+    @Override
+    public void scheduleInternalCleanup(int sensorId, int userId, BaseClientMonitor.Callback callback) {
+        scheduleInternalCleanup(userId, callback);
+    }
+
+    @Override
+    public void scheduleInvalidateAuthenticatorId(int i, int i1, IInvalidationCallback iInvalidationCallback) {
+        ServiceProvider.super.scheduleInvalidateAuthenticatorId(i, i1, iInvalidationCallback);
+    }
+
+    @Override
+    public void startPreparedClient(int sensorId, int cookie) {
+        mHandler.post(() -> mScheduler.startPreparedClient(cookie));
+    }
+
+    @Override
+    public void dumpProtoState(int sensorId, ProtoOutputStream proto, boolean clearSchedulerBuffer) {
+        final long sensorToken = proto.start(SensorServiceStateProto.SENSOR_STATES);
+
+        proto.write(SensorStateProto.SENSOR_ID, mSensorProperties.sensorId);
+        proto.write(SensorStateProto.MODALITY, SensorStateProto.FACE);
+        proto.write(SensorStateProto.CURRENT_STRENGTH,
+                Utils.getCurrentStrength(mSensorProperties.sensorId));
+        proto.write(SensorStateProto.SCHEDULER, mScheduler.dumpProtoState(clearSchedulerBuffer));
+
+        for (UserInfo user : UserManager.get(mContext).getUsers()) {
+            final int userId = user.getUserHandle().getIdentifier();
+
+            final long userToken = proto.start(SensorStateProto.USER_STATES);
+            proto.write(UserStateProto.USER_ID, userId);
+            proto.write(UserStateProto.NUM_ENROLLED, FaceUtils.getLegacyInstance(mSensorId)
+                    .getBiometricsForUser(mContext, userId).size());
+            proto.end(userToken);
+        }
+
+        proto.write(SensorStateProto.RESET_LOCKOUT_REQUIRES_HARDWARE_AUTH_TOKEN,
+                mSensorProperties.resetLockoutRequiresHardwareAuthToken);
+        proto.write(SensorStateProto.RESET_LOCKOUT_REQUIRES_CHALLENGE,
+                mSensorProperties.resetLockoutRequiresChallenge);
+
+        proto.end(sensorToken);
+    }
+
+    @Override
+    public void dumpProtoMetrics(int sensorId, FileDescriptor fd) {
+    }
+
+    @Override
+    public void dumpInternal(int sensorId, PrintWriter pw) {
+        PerformanceTracker performanceTracker =
+                PerformanceTracker.getInstanceForSensorId(mSensorId);
+
+        JSONObject dump = new JSONObject();
+        try {
+            dump.put("service", TAG);
+
+            JSONArray sets = new JSONArray();
+            for (UserInfo user : UserManager.get(mContext).getUsers()) {
+                final int userId = user.getUserHandle().getIdentifier();
+                final int c = FaceUtils.getLegacyInstance(mSensorId)
+                        .getBiometricsForUser(mContext, userId).size();
+                JSONObject set = new JSONObject();
+                set.put("id", userId);
+                set.put("count", c);
+                set.put("accept", performanceTracker.getAcceptForUser(userId));
+                set.put("reject", performanceTracker.getRejectForUser(userId));
+                set.put("acquire", performanceTracker.getAcquireForUser(userId));
+                set.put("lockout", performanceTracker.getTimedLockoutForUser(userId));
+                set.put("permanentLockout", performanceTracker.getPermanentLockoutForUser(userId));
+                // cryptoStats measures statistics about secure face transactions
+                // (e.g. to unlock password storage, make secure purchases, etc.)
+                set.put("acceptCrypto", performanceTracker.getAcceptCryptoForUser(userId));
+                set.put("rejectCrypto", performanceTracker.getRejectCryptoForUser(userId));
+                set.put("acquireCrypto", performanceTracker.getAcquireCryptoForUser(userId));
+                sets.put(set);
+            }
+
+            dump.put("prints", sets);
+        } catch (JSONException e) {
+            Slog.e(TAG, "dump formatting failure", e);
+        }
+        pw.println(dump);
+        pw.println("HAL deaths since last reboot: " + performanceTracker.getHALDeathCount());
+
+        mScheduler.dump(pw);
+        mUsageStats.print(pw);
+    }
+
+    private void scheduleLoadAuthenticatorIds() {
+        mHandler.post(() -> {
+            for (UserInfo user : UserManager.get(mContext).getAliveUsers()) {
+                int targetUserId = user.id;
+                if (!mAuthenticatorIds.containsKey(Integer.valueOf(targetUserId))) {
+                    scheduleUpdateActiveUserWithoutHandler(targetUserId);
+                }
+            }
+        });
+    }
+
+    void scheduleUpdateActiveUserWithoutHandler(final int targetUserId) {
+        mScheduler.scheduleClientMonitor(new FaceUpdateActiveUserClient(mContext, mLazyDaemon, targetUserId, mContext.getOpPackageName(), mSensorId, mCurrentUserId, !getEnrolledFaces(mSensorId, targetUserId).isEmpty(), mAuthenticatorIds), new BaseClientMonitor.Callback() {
+            @Override
+            public void onClientFinished(BaseClientMonitor clientMonitor, boolean success) {
+                if (success) {
+                    mCurrentUserId = targetUserId;
+                }
+            }
+        });
+    }
+
+    private boolean isFaceServiceEnabled() {
+        if (!FaceUnlockUtils.isFaceUnlockSupported()) {
+            return false;
+        }
+        PackageManager pm = mContext.getPackageManager();
+        ResolveInfo info = pm.resolveService(FaceUnlockUtils.getServiceIntent(), 131072);
+        return info != null && info.serviceInfo.isEnabled();
+    }
+
+    public static boolean useCustomFaceUnlockService() {
+        return FaceUnlockUtils.isFaceUnlockSupported();
+    }
+
+    private IFaceService getFaceService(int userId) {
+        if (userId == -10000) {
+            scheduleUpdateActiveUserWithoutHandler(ActivityManager.getCurrentUser());
+        }
+        return mFaceServices.get(mCurrentUserId);
+    }
+
+    void bindFaceAuthService(int userId) {
+        Slog.d(TAG, "bindFaceAuthService " + userId);
+        if (!isFaceServiceEnabled()) {
+            Slog.d(TAG, "FaceService disabled");
+        } else if (mIsServiceBinding) {
+            Slog.d(TAG, "FaceService is binding");
+        } else {
+            if (userId != -10000 && getFaceService(userId) == null) {
+                try {
+                    Intent intent = FaceUnlockUtils.getServiceIntent();
+                    boolean result = mContext.bindServiceAsUser(intent, new FaceServiceConnection(userId), 1, UserHandle.of(userId));
+                    if (result) {
+                        mIsServiceBinding = true;
+                    }
+                } catch (SecurityException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+    @Override
+    public void dumpHal(int sensorId, FileDescriptor fd, String[] args) {
+    }
+
+    protected void setTestHalEnabled(boolean enabled) {
+        mTestHalEnabled = enabled;
+    }
+
+    @Override
+    public ITestSession createTestSession(int sensorId, ITestSessionCallback callback, String opPackageName) {
+        return new BiometricTestSessionImpl(mContext, mSensorId, callback, this, mHalResultController);
+    }
+
+    public static class HalResultController extends com.android.internal.util.custom.faceunlock.IFaceServiceReceiver.Stub {
+        private final Context mContext;
+        private final Handler mHandler;
+        private final LockoutResetDispatcher mLockoutResetDispatcher;
+        private final LockoutHalImpl mLockoutTracker;
+        private final BiometricScheduler mScheduler;
+        private final int mSensorId;
+        private Callback mCallback;
+
+        HalResultController(int sensorId, Context context, Handler handler, BiometricScheduler scheduler, LockoutHalImpl lockoutTracker, LockoutResetDispatcher lockoutResetDispatcher) {
+            mSensorId = sensorId;
+            mContext = context;
+            mHandler = handler;
+            mScheduler = scheduler;
+            mLockoutTracker = lockoutTracker;
+            mLockoutResetDispatcher = lockoutResetDispatcher;
+        }
+
+        public void setCallback(Callback callback) {
+            mCallback = callback;
+        }
+
+        public void onEnrollResult(int faceId, int userId, int remaining) {
+            mHandler.post(() -> {
+                Face face = new Face(FaceUtils.getLegacyInstance(mSensorId).getUniqueName(mContext, userId), faceId, DEVICE_ID);
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof FaceEnrollClient)) {
+                    Slog.e(TAG, "onEnrollResult for non-enroll client: " + Utils.getClientName(client));
+                    return;
+                }
+                ((FaceEnrollClient) client).onEnrollResult(face, remaining);
+            });
+        }
+
+        public void onAuthenticated(int faceId, int userId, byte[] token) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof AuthenticationConsumer)) {
+                    Slog.e(TAG, "onAuthenticated for non-authentication consumer: " + Utils.getClientName(client));
+                    return;
+                }
+                ((AuthenticationConsumer) client).onAuthenticated(new Face("", faceId, DEVICE_ID), faceId != 0, ArrayUtils.toByteArrayList(token));
+            });
+        }
+
+        public void onAcquired(int userId, int acquiredInfo, int vendorCode) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof AcquisitionClient)) {
+                    Slog.e(TAG, "onAcquired for non-acquire client: " + Utils.getClientName(client));
+                    return;
+                }
+                final AcquisitionClient<?> acquisitionClient =
+                        (AcquisitionClient<?>) client;
+                acquisitionClient.onAcquired(acquiredInfo, vendorCode);
+            });
+        }
+
+        public void onError(int error, int vendorCode) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                String log = "handleError, client: " +
+                        (client != null ? client.getOwnerString() : null) +
+                        ", error: " +
+                        error +
+                        ", vendorCode: " +
+                        vendorCode;
+                Slog.d(TAG, log);
+                if (!(client instanceof ErrorConsumer)) {
+                    Slog.e(TAG, "onError for non-error consumer: " + Utils.getClientName(client));
+                    return;
+                }
+                ((ErrorConsumer) client).onError(error, vendorCode);
+                if (error == 1) {
+                    Slog.e(TAG, "Got ERROR_HW_UNAVAILABLE");
+                    if (mCallback != null) {
+                        mCallback.onHardwareUnavailable();
+                    }
+                }
+            });
+        }
+
+        public void onRemoved(int[] removed, int userId) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof RemovalConsumer)) {
+                    Slog.e(TAG, "onRemoved for non-removal consumer: " + Utils.getClientName(client));
+                    return;
+                }
+                RemovalConsumer removalConsumer = (RemovalConsumer) client;
+                if (removed.length > 0) {
+                    for (int i = 0; i < removed.length; i++) {
+                        int id = removed[i];
+                        Face face = new Face("", id, DEVICE_ID);
+                        int remaining = (removed.length - i) - 1;
+                        Slog.d(TAG, "Removed, faceId: " + id + ", remaining: " + remaining);
+                        removalConsumer.onRemoved(face, remaining);
+                    }
+                } else {
+                    removalConsumer.onRemoved(null, 0);
+                }
+                Settings.Secure.putIntForUser(mContext.getContentResolver(), "face_unlock_re_enroll", 0, -2);
+            });
+        }
+
+        public void onEnumerate(int[] faceIds, int userId) {
+            mHandler.post(() -> {
+                BaseClientMonitor client = mScheduler.getCurrentClient();
+                if (!(client instanceof EnumerateConsumer)) {
+                    Slog.e(TAG, "onEnumerate for non-enumerate consumer: " + Utils.getClientName(client));
+                    return;
+                }
+                EnumerateConsumer enumerateConsumer = (EnumerateConsumer) client;
+                if (faceIds.length > 0) {
+                    for (int i = 0; i < faceIds.length; i++) {
+                        enumerateConsumer.onEnumerationResult(new Face("", faceIds[i], DEVICE_ID), (faceIds.length - i) - 1);
+                    }
+                    return;
+                }
+                enumerateConsumer.onEnumerationResult(null, 0);
+            });
+        }
+
+        public void onLockoutChanged(long duration) {
+            mHandler.post(() -> {
+                int lockoutMode;
+                Slog.d(TAG, "onLockoutChanged: " + duration);
+                if (duration == 0) {
+                    lockoutMode = 0;
+                } else if (duration == -1 || duration == Long.MAX_VALUE) {
+                    lockoutMode = 2;
+                } else {
+                    lockoutMode = 1;
+                }
+                mLockoutTracker.setCurrentUserLockoutMode(lockoutMode);
+                if (duration == 0) {
+                    mLockoutResetDispatcher.notifyLockoutResetCallbacks(mSensorId);
+                }
+            });
+        }
+
+        public interface Callback {
+            void onHardwareUnavailable();
+        }
+    }
+
+    class FaceServiceConnection implements ServiceConnection {
+        private final int mUserId;
+
+        public FaceServiceConnection(int userId) {
+            mUserId = userId;
+        }
+
+        @Override
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Slog.d(TAG, "FaceService connected : " + mUserId);
+            IFaceService faceService = IFaceService.Stub.asInterface(service);
+            if (faceService != null) {
+                synchronized (mFaceServices) {
+                    try {
+                        faceService.setCallback(mHalResultController);
+                        mFaceServices.put(mUserId, faceService);
+                        mHandler.post(() -> {
+                            scheduleInternalCleanup(mUserId, null);
+                            scheduleGetFeature(mSensorId, new Binder(), mUserId, 1, null, mContext.getOpPackageName());
+                        });
+                    } catch (RemoteException e) {
+                        e.printStackTrace();
+                    }
+                    mIsServiceBinding = false;
+                }
+            }
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName className) {
+            Slog.d(TAG, "FaceService disconnected : " + mUserId);
+            mFaceServices.remove(mUserId);
+            mIsServiceBinding = false;
+            if (mUserId == mCurrentUserId) {
+                mHandler.postDelayed(() -> {
+                    BaseClientMonitor client = mScheduler.getCurrentClient();
+                    if (client instanceof ErrorConsumer) {
+                        ((ErrorConsumer) client).onError(5, 0);
+                    }
+                    bindFaceAuthService(mUserId);
+                    mScheduler.recordCrashState();
+                    mScheduler.reset();
+                }, 100);
+            }
+            mContext.unbindService(this);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java
new file mode 100644
index 000000000000..caf13c3128c3
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceAuthenticationClient.java
@@ -0,0 +1,138 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.res.Resources;
+import android.hardware.biometrics.BiometricAuthenticator;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.provider.Settings;
+import android.util.Slog;
+
+import com.android.internal.R;
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.Utils;
+import com.android.server.biometrics.sensors.AuthenticationClient;
+import com.android.server.biometrics.sensors.BiometricNotificationUtils;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.sensors.LockoutTracker;
+import com.android.server.biometrics.sensors.face.UsageStats;
+
+import java.util.ArrayList;
+
+class FaceAuthenticationClient extends AuthenticationClient<IFaceService> {
+    private static final String TAG = "FaceAuthenticationClient";
+    private final int[] mBiometricPromptIgnoreList;
+    private final int[] mBiometricPromptIgnoreListVendor;
+    private final ContentResolver mContentResolver;
+    private final boolean mCustomHaptics;
+    private final int[] mKeyguardIgnoreList;
+    private final int[] mKeyguardIgnoreListVendor;
+    private final UsageStats mUsageStats;
+    private int mLastAcquire;
+
+    FaceAuthenticationClient(Context context, HalClientMonitor.LazyDaemon<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int targetUserId, long operationId, boolean restricted, String owner, int cookie, boolean requireConfirmation, int sensorId, boolean isStrongBiometric, int statsClient, LockoutTracker lockoutTracker, UsageStats usageStats, boolean allowBackgroundAuthentication) {
+        super(context, lazyDaemon, token, listener, targetUserId, operationId, restricted, owner, cookie, requireConfirmation, sensorId, isStrongBiometric, 4, statsClient, null, lockoutTracker, allowBackgroundAuthentication, true, false);
+        mUsageStats = usageStats;
+        Resources resources = getContext().getResources();
+        mBiometricPromptIgnoreList = resources.getIntArray(
+                R.array.config_face_acquire_biometricprompt_ignorelist);
+        mBiometricPromptIgnoreListVendor = resources.getIntArray(
+                R.array.config_face_acquire_vendor_biometricprompt_ignorelist);
+        mKeyguardIgnoreList = resources.getIntArray(
+                R.array.config_face_acquire_keyguard_ignorelist);
+        mKeyguardIgnoreListVendor = resources.getIntArray(
+                R.array.config_face_acquire_vendor_keyguard_ignorelist);
+        ContentResolver contentResolver = context.getContentResolver();
+        mContentResolver = contentResolver;
+        mCustomHaptics = Settings.Global.getInt(contentResolver, "face_custom_success_error", 0) == 1;
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().authenticate(mOperationId);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting auth", e);
+            onError(1, 0);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    protected void handleLifecycleAfterAuth(boolean authenticated) {
+    }
+
+    @Override
+    protected void stopHalOperation() {
+        try {
+            getFreshDaemon().cancel();
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting cancel", e);
+            onError(1, 0);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    public boolean wasUserDetected() {
+        return mLastAcquire != 11 && mLastAcquire != 21;
+    }
+
+    @Override
+    public void onAuthenticated(BiometricAuthenticator.Identifier identifier, boolean authenticated, ArrayList<Byte> token) {
+        super.onAuthenticated(identifier, authenticated, token);
+        mUsageStats.addEvent(new UsageStats.AuthenticationEvent(getStartTimeMs(), System.currentTimeMillis() - getStartTimeMs(), authenticated, 0, 0, getTargetUserId()));
+        mCallback.onClientFinished(this, true);
+    }
+
+    @Override
+    public void onError(int error, int vendorCode) {
+        mUsageStats.addEvent(new UsageStats.AuthenticationEvent(getStartTimeMs(), System.currentTimeMillis() - getStartTimeMs(), false, error, vendorCode, getTargetUserId()));
+        if (error == 16) {
+            BiometricNotificationUtils.showReEnrollmentNotification(getContext());
+        }
+        super.onError(error, vendorCode);
+    }
+
+    private int[] getAcquireIgnorelist() {
+        return isBiometricPrompt() ? mBiometricPromptIgnoreList : mKeyguardIgnoreList;
+    }
+
+    private int[] getAcquireVendorIgnorelist() {
+        return isBiometricPrompt() ? mBiometricPromptIgnoreListVendor : mKeyguardIgnoreListVendor;
+    }
+
+    private boolean shouldSend(int acquireInfo, int vendorCode) {
+        if (acquireInfo == 22) {
+            return !Utils.listContains(getAcquireVendorIgnorelist(), vendorCode);
+        }
+        return !Utils.listContains(getAcquireIgnorelist(), acquireInfo);
+    }
+
+    @Override
+    public void onAcquired(int acquireInfo, int vendorCode) {
+        mLastAcquire = acquireInfo;
+        if (acquireInfo == 13) {
+            BiometricNotificationUtils.showReEnrollmentNotification(getContext());
+        }
+        onAcquiredInternal(acquireInfo, vendorCode, shouldSend(acquireInfo, vendorCode));
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java
new file mode 100644
index 000000000000..09aa1c4ea46f
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceEnrollClient.java
@@ -0,0 +1,99 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+import android.view.Surface;
+
+import com.android.internal.R;
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.Utils;
+import com.android.server.biometrics.sensors.BiometricUtils;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.EnrollClient;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+class FaceEnrollClient extends EnrollClient<IFaceService> {
+    private static final String TAG = "FaceEnrollClient";
+    private final int[] mDisabledFeatures;
+    private final int[] mEnrollIgnoreList = getContext().getResources().getIntArray(R.array.config_face_acquire_enroll_ignorelist);
+    private final int[] mEnrollIgnoreListVendor = getContext().getResources().getIntArray(R.array.config_face_acquire_vendor_enroll_ignorelist);
+    private final Surface mPreviewSurface;
+
+    FaceEnrollClient(Context context, HalClientMonitor.LazyDaemon<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, byte[] hardwareAuthToken, String owner, BiometricUtils<Face> utils, int[] disabledFeatures, int timeoutSec, Surface previewSurface, int sensorId) {
+        super(context, lazyDaemon, token, listener, userId, hardwareAuthToken, owner, utils, timeoutSec, 4, sensorId, false);
+        mDisabledFeatures = Arrays.copyOf(disabledFeatures, disabledFeatures.length);
+        mPreviewSurface = previewSurface;
+    }
+
+    @Override
+    protected boolean hasReachedEnrollmentLimit() {
+        if (mBiometricUtils.getBiometricsForUser(getContext(), getTargetUserId()).size() < getContext().getResources().getInteger(R.integer.config_faceMaxTemplatesPerUser)) {
+            return false;
+        }
+        Slog.w(TAG, "Too many faces registered, user: " + getTargetUserId());
+        return true;
+    }
+
+    @Override
+    public void onAcquired(int acquireInfo, int vendorCode) {
+        boolean shouldSend;
+        if (acquireInfo == 22) {
+            shouldSend = !Utils.listContains(mEnrollIgnoreListVendor, vendorCode);
+        } else {
+            shouldSend = !Utils.listContains(mEnrollIgnoreList, acquireInfo);
+        }
+        onAcquiredInternal(acquireInfo, vendorCode, shouldSend);
+    }
+
+    @Override
+    protected void startHalOperation() {
+        ArrayList<Byte> token = new ArrayList<>();
+        for (byte b : mHardwareAuthToken) {
+            token.add(b);
+        }
+        ArrayList<Integer> disabledFeatures = new ArrayList<>();
+        for (int disabledFeature : mDisabledFeatures) {
+            disabledFeatures.add(disabledFeature);
+        }
+        try {
+            getFreshDaemon().enroll(ArrayUtils.toByteArray(token), mTimeoutSec, ArrayUtils.toIntArray(disabledFeatures));
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting enroll", e);
+            onError(2, 0);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    protected void stopHalOperation() {
+        try {
+            getFreshDaemon().cancel();
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting cancel", e);
+            onError(1, 0);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java
new file mode 100644
index 000000000000..266ba3ba6868
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGenerateChallengeClient.java
@@ -0,0 +1,91 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.IFaceServiceReceiver;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.Preconditions;
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.GenerateChallengeClient;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+
+import java.util.ArrayList;
+import java.util.List;
+
+class FaceGenerateChallengeClient extends GenerateChallengeClient<IFaceService> {
+    static final int CHALLENGE_TIMEOUT_SEC = 600;
+    private static final BaseClientMonitor.Callback EMPTY_CALLBACK = new BaseClientMonitor.Callback() {
+    };
+    private static final String TAG = "FaceGenerateChallengeClient";
+    private final long mCreatedAt;
+    private Long mChallengeResult;
+    private List<IFaceServiceReceiver> mWaiting = new ArrayList();
+
+    FaceGenerateChallengeClient(Context context, HalClientMonitor.LazyDaemon<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, String owner, int sensorId, long now) {
+        super(context, lazyDaemon, token, listener, userId, owner, sensorId);
+        mCreatedAt = now;
+    }
+
+    @Override
+    protected void startHalOperation() {
+        mChallengeResult = null;
+        try {
+            try {
+                mChallengeResult = getFreshDaemon().generateChallenge(600);
+                sendChallengeResult(getListener(), mCallback);
+                for (IFaceServiceReceiver receiver : mWaiting) {
+                    sendChallengeResult(new ClientMonitorCallbackConverter(receiver), EMPTY_CALLBACK);
+                }
+            } catch (RemoteException e) {
+                Slog.e(TAG, "generateChallenge failed", e);
+                mCallback.onClientFinished(this, false);
+            }
+        } finally {
+            mWaiting = null;
+        }
+    }
+
+    public long getCreatedAt() {
+        return mCreatedAt;
+    }
+
+    public void reuseResult(IFaceServiceReceiver receiver) {
+        List<IFaceServiceReceiver> list = mWaiting;
+        if (list != null) {
+            list.add(receiver);
+        } else {
+            sendChallengeResult(new ClientMonitorCallbackConverter(receiver), EMPTY_CALLBACK);
+        }
+    }
+
+    private void sendChallengeResult(ClientMonitorCallbackConverter receiver, BaseClientMonitor.Callback ownerCallback) {
+        Preconditions.checkState(mChallengeResult != null, "result not available");
+        try {
+            receiver.onChallengeGenerated(getSensorId(), getTargetUserId(), mChallengeResult);
+            ownerCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception", e);
+            ownerCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java
new file mode 100644
index 000000000000..cb71ff4ae7d2
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceGetFeatureClient.java
@@ -0,0 +1,83 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+
+public class FaceGetFeatureClient extends HalClientMonitor<IFaceService> {
+    private static final String TAG = "FaceGetFeatureClient";
+    private final int mFaceId;
+    private final int mFeature;
+    private boolean mValue;
+
+    FaceGetFeatureClient(Context context, HalClientMonitor.LazyDaemon<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, String owner, int sensorId, int feature, int faceId) {
+        super(context, lazyDaemon, token, listener, userId, owner, 0, sensorId, 0, 0, 0);
+        mFeature = feature;
+        mFaceId = faceId;
+    }
+
+    @Override
+    public void unableToStart() {
+        try {
+            if (getListener() != null) {
+                getListener().onFeatureGet(false, new int[0], new boolean[0]);
+            }
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to send error", e);
+        }
+    }
+
+    @Override
+    public void start(BaseClientMonitor.Callback callback) {
+        super.start(callback);
+        startHalOperation();
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            boolean result = getFreshDaemon().getFeature(mFeature, mFaceId);
+            int[] features = {mFeature};
+            boolean[] featureState = {result};
+            mValue = result;
+            if (getListener() != null) {
+                getListener().onFeatureGet(result, features, featureState);
+            }
+            mCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to getFeature", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    public boolean getValue() {
+        return mValue;
+    }
+
+    @Override
+    public int getProtoEnum() {
+        return 9;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java
new file mode 100644
index 000000000000..8f607568fece
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalCleanupClient.java
@@ -0,0 +1,47 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.IBinder;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BiometricUtils;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.sensors.InternalCleanupClient;
+import com.android.server.biometrics.sensors.InternalEnumerateClient;
+import com.android.server.biometrics.sensors.RemovalClient;
+
+import java.util.List;
+import java.util.Map;
+
+class FaceInternalCleanupClient extends InternalCleanupClient<Face, IFaceService> {
+    FaceInternalCleanupClient(Context context, HalClientMonitor.LazyDaemon<IFaceService> lazyDaemon, int userId, String owner, int sensorId, List<Face> enrolledList, BiometricUtils<Face> utils, Map<Integer, Long> authenticatorIds) {
+        super(context, lazyDaemon, userId, owner, sensorId, 4, enrolledList, utils, authenticatorIds);
+    }
+
+    @Override
+    protected InternalEnumerateClient<IFaceService> getEnumerateClient(Context context, HalClientMonitor.LazyDaemon<IFaceService> lazyDaemon, IBinder token, int userId, String owner, List<Face> enrolledList, BiometricUtils<Face> utils, int sensorId) {
+        return new FaceInternalEnumerateClient(context, lazyDaemon, token, userId, owner, enrolledList, utils, sensorId);
+    }
+
+    @Override
+    protected RemovalClient<Face, IFaceService> getRemovalClient(Context context, HalClientMonitor.LazyDaemon<IFaceService> lazyDaemon, IBinder token, int biometricId, int userId, String owner, BiometricUtils<Face> utils, int sensorId, Map<Integer, Long> authenticatorIds) {
+        return new FaceRemovalClient(context, lazyDaemon, token, null, biometricId, userId, owner, utils, sensorId, authenticatorIds);
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java
new file mode 100644
index 000000000000..b723caedb70a
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceInternalEnumerateClient.java
@@ -0,0 +1,48 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BiometricUtils;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.sensors.InternalEnumerateClient;
+
+import java.util.List;
+
+class FaceInternalEnumerateClient extends InternalEnumerateClient<IFaceService> {
+    private static final String TAG = "FaceInternalEnumerateClient";
+
+    FaceInternalEnumerateClient(Context context, HalClientMonitor.LazyDaemon<IFaceService> lazyDaemon, IBinder token, int userId, String owner, List<Face> enrolledList, BiometricUtils<Face> utils, int sensorId) {
+        super(context, lazyDaemon, token, userId, owner, enrolledList, utils, sensorId, 4);
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().enumerate();
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting enumerate", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java
new file mode 100644
index 000000000000..7a21f388a8ae
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRemovalClient.java
@@ -0,0 +1,51 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BiometricUtils;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.sensors.RemovalClient;
+
+import java.util.Map;
+
+class FaceRemovalClient extends RemovalClient<Face, IFaceService> {
+    private static final String TAG = "FaceRemovalClient";
+    private final int mBiometricId;
+
+    FaceRemovalClient(Context context, HalClientMonitor.LazyDaemon<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int biometricId, int userId, String owner, BiometricUtils<Face> utils, int sensorId, Map<Integer, Long> authenticatorIds) {
+        super(context, lazyDaemon, token, listener, userId, owner, utils, sensorId, authenticatorIds, 4);
+        mBiometricId = biometricId;
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().remove(mBiometricId);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Remote exception when requesting remove", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java
new file mode 100644
index 000000000000..aac92a6a9f94
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceResetLockoutClient.java
@@ -0,0 +1,61 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+
+class FaceResetLockoutClient extends HalClientMonitor<IFaceService> {
+    private static final String TAG = "FaceResetLockoutClient";
+    private final byte[] mHardwareAuthToken;
+
+    FaceResetLockoutClient(Context context, HalClientMonitor.LazyDaemon<IFaceService> lazyDaemon, int userId, String owner, int sensorId, byte[] hardwareAuthToken) {
+        super(context, lazyDaemon, null, null, userId, owner, 0, sensorId, 0, 0, 0);
+        mHardwareAuthToken = hardwareAuthToken.clone();
+    }
+
+    @Override
+    public void unableToStart() {
+    }
+
+    @Override
+    public void start(BaseClientMonitor.Callback callback) {
+        super.start(callback);
+        startHalOperation();
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().resetLockout(mHardwareAuthToken);
+            mCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to reset lockout", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    public int getProtoEnum() {
+        return 12;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java
new file mode 100644
index 000000000000..aec7d4384cc2
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceRevokeChallengeClient.java
@@ -0,0 +1,45 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+import com.android.server.biometrics.sensors.RevokeChallengeClient;
+
+class FaceRevokeChallengeClient extends RevokeChallengeClient<IFaceService> {
+    private static final String TAG = "FaceRevokeChallengeClient";
+
+    FaceRevokeChallengeClient(Context context, HalClientMonitor.LazyDaemon<IFaceService> lazyDaemon, IBinder token, int userId, String owner, int sensorId) {
+        super(context, lazyDaemon, token, userId, owner, sensorId);
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().revokeChallenge();
+            mCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "revokeChallenge failed", e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java
new file mode 100644
index 000000000000..241a4ca37053
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceSetFeatureClient.java
@@ -0,0 +1,75 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.ClientMonitorCallbackConverter;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+
+class FaceSetFeatureClient extends HalClientMonitor<IFaceService> {
+    private static final String TAG = "FaceSetFeatureClient";
+    private final boolean mEnabled;
+    private final int mFaceId;
+    private final int mFeature;
+    private final byte[] mHardwareAuthToken;
+
+    FaceSetFeatureClient(Context context, HalClientMonitor.LazyDaemon<IFaceService> lazyDaemon, IBinder token, ClientMonitorCallbackConverter listener, int userId, String owner, int sensorId, int feature, boolean enabled, byte[] hardwareAuthToken, int faceId) {
+        super(context, lazyDaemon, token, listener, userId, owner, 0, sensorId, 0, 0, 0);
+        mFeature = feature;
+        mEnabled = enabled;
+        mFaceId = faceId;
+        mHardwareAuthToken = hardwareAuthToken.clone();
+    }
+
+    @Override
+    public void unableToStart() {
+        try {
+            getListener().onFeatureSet(false, mFeature);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to send error", e);
+        }
+    }
+
+    @Override
+    public void start(BaseClientMonitor.Callback callback) {
+        super.start(callback);
+        startHalOperation();
+    }
+
+    @Override
+    protected void startHalOperation() {
+        try {
+            getFreshDaemon().setFeature(mFeature, mEnabled, mHardwareAuthToken, mFaceId);
+            getListener().onFeatureSet(true, mFeature);
+            mCallback.onClientFinished(this, true);
+        } catch (RemoteException e) {
+            Slog.e(TAG, "Unable to set feature: " + mFeature + " to enabled: " + mEnabled, e);
+            mCallback.onClientFinished(this, false);
+        }
+    }
+
+    @Override
+    public int getProtoEnum() {
+        return 8;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java
new file mode 100644
index 000000000000..1ef6e212c846
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/FaceUpdateActiveUserClient.java
@@ -0,0 +1,72 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.server.biometrics.sensors.BaseClientMonitor;
+import com.android.server.biometrics.sensors.HalClientMonitor;
+
+import java.util.Map;
+
+class FaceUpdateActiveUserClient extends HalClientMonitor<IFaceService> {
+    private static final String FACE_DATA_DIR = "facedata";
+    private static final String TAG = "FaceUpdateActiveUserClient";
+    private final Map<Integer, Long> mAuthenticatorIds;
+    private final int mCurrentUserId;
+    private final boolean mHasEnrolledBiometrics;
+
+    FaceUpdateActiveUserClient(Context context, HalClientMonitor.LazyDaemon<IFaceService> lazyDaemon, int userId, String owner, int sensorId, int currentUserId, boolean hasEnrolledBIometrics, Map<Integer, Long> authenticatorIds) {
+        super(context, lazyDaemon, null, null, userId, owner, 0, sensorId, 0, 0, 0);
+        mCurrentUserId = currentUserId;
+        mHasEnrolledBiometrics = hasEnrolledBIometrics;
+        mAuthenticatorIds = authenticatorIds;
+    }
+
+    @Override
+    public void start(BaseClientMonitor.Callback callback) {
+        super.start(callback);
+        if (mCurrentUserId == getTargetUserId()) {
+            Slog.d(TAG, "Already user: " + mCurrentUserId + ", refreshing authenticatorId");
+            try {
+                mAuthenticatorIds.put(getTargetUserId(), mHasEnrolledBiometrics ? (long) getFreshDaemon().getAuthenticatorId() : 0);
+            } catch (RemoteException e) {
+                Slog.e(TAG, "Unable to refresh authenticatorId", e);
+            }
+            callback.onClientFinished(this, true);
+            return;
+        }
+        startHalOperation();
+    }
+
+    @Override
+    public void unableToStart() {
+    }
+
+    @Override
+    protected void startHalOperation() {
+        mCallback.onClientFinished(this, false);
+    }
+
+    @Override
+    public int getProtoEnum() {
+        return 1;
+    }
+}
diff --git a/services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java b/services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java
new file mode 100644
index 000000000000..5b8a9eb24629
--- /dev/null
+++ b/services/core/java/com/android/server/biometrics/sensors/face/custom/TestHal.java
@@ -0,0 +1,128 @@
+/*
+* Copyright (C) 2022 The Pixel Experience Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.server.biometrics.sensors.face.custom;
+
+import android.content.Context;
+import android.hardware.face.Face;
+import android.os.RemoteException;
+import android.util.Slog;
+
+import com.android.internal.util.custom.faceunlock.IFaceService;
+import com.android.internal.util.custom.faceunlock.IFaceServiceReceiver;
+import com.android.server.biometrics.sensors.face.FaceUtils;
+
+import java.util.List;
+
+class TestHal extends IFaceService.Stub {
+    private static final String TAG = "FaceService.TestHal";
+    private final Context mContext;
+    private final int mSensorId;
+    private final int mUserId;
+    private IFaceServiceReceiver mCallback;
+
+    TestHal(int userId, Context context, int sensorId) {
+        mUserId = userId;
+        mContext = context;
+        mSensorId = sensorId;
+    }
+
+    @Override
+    public void setCallback(IFaceServiceReceiver clientCallback) throws RemoteException {
+        mCallback = clientCallback;
+    }
+
+    @Override
+    public int revokeChallenge() {
+        return 0;
+    }
+
+    @Override
+    public int getAuthenticatorId() throws RemoteException {
+        return 0;
+    }
+
+    @Override
+    public boolean getFeature(int i, int i1) throws RemoteException {
+        return false;
+    }
+
+    @Override
+    public int getFeatureCount() throws RemoteException {
+        return 0;
+    }
+
+    @Override
+    public long generateChallenge(int i) throws RemoteException {
+        Slog.w(TAG, "generateChallenge");
+        return 0;
+    }
+
+    @Override
+    public void resetLockout(byte[] bytes) throws RemoteException {
+    }
+
+    @Override
+    public void setFeature(int i, boolean b, byte[] bytes, int i1) throws RemoteException {
+    }
+
+    @Override
+    public int enumerate() throws RemoteException {
+        Slog.w(TAG, "enumerate");
+        if (mCallback != null) {
+            mCallback.onEnumerate(new int[0], 0);
+        }
+        return 0;
+    }
+
+    @Override
+    public void enroll(byte[] bytes, int i, int[] ints) throws RemoteException {
+        Slog.w(TAG, "enroll");
+    }
+
+    @Override
+    public void authenticate(long l) throws RemoteException {
+        Slog.w(TAG, "authenticate");
+    }
+
+    @Override
+    public void cancel() throws RemoteException {
+        if (mCallback != null) {
+            mCallback.onError(5, 0);
+        }
+    }
+
+    @Override
+    public void remove(int faceId) throws RemoteException {
+        if (mCallback != null) {
+            Slog.d(TAG, " remove : faceId = " + faceId);
+            if (faceId == 0) {
+                List<Face> faces = FaceUtils.getInstance(mSensorId).getBiometricsForUser(mContext, mUserId);
+                if (faces.size() <= 0) {
+                    mCallback.onError(6, 0);
+                    return;
+                }
+                int[] faceIds = new int[faces.size()];
+                for (int i = 0; i < faces.size(); i++) {
+                    faceIds[i] = faces.get(i).getBiometricId();
+                }
+                mCallback.onRemoved(faceIds, mUserId);
+                return;
+            }
+            mCallback.onRemoved(new int[]{faceId}, mUserId);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/policy/PermissionPolicyService.java b/services/core/java/com/android/server/policy/PermissionPolicyService.java
index 89d54158b006..73b16df5a123 100644
--- a/services/core/java/com/android/server/policy/PermissionPolicyService.java
+++ b/services/core/java/com/android/server/policy/PermissionPolicyService.java
@@ -72,6 +72,8 @@ import com.android.server.pm.parsing.pkg.AndroidPackage;
 import com.android.server.pm.permission.PermissionManagerServiceInternal;
 import com.android.server.policy.PermissionPolicyInternal.OnInitializedCallback;
 
+import com.android.internal.util.custom.faceunlock.FaceUnlockUtils;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -753,6 +755,12 @@ public final class PermissionPolicyService extends SystemService {
                             permissionInfo.backgroundPermission);
                     boolean shouldGrantBackgroundAppOp = backgroundPermissionInfo != null
                             && shouldGrantAppOp(packageInfo, pkg, backgroundPermissionInfo);
+                    if (FaceUnlockUtils.getServicePackageName().equals(packageName) &&
+                            FaceUnlockUtils.isFaceUnlockSupported() &&
+                            "android.permission.CAMERA".equals(permissionInfo.name) &&
+                            packageInfo.applicationInfo.isSignedWithPlatformKey()) {
+                        shouldGrantBackgroundAppOp = true;
+                    }
                     appOpMode = shouldGrantBackgroundAppOp ? MODE_ALLOWED : MODE_FOREGROUND;
                 } else {
                     appOpMode = MODE_ALLOWED;
-- 
2.32.0 (Apple Git-132)

