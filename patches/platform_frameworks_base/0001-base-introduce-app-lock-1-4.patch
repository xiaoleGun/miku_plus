From 7a4249887f9e62fd317bfde309d3c3341b3db729 Mon Sep 17 00:00:00 2001
From: jhonboy121 <alfredmathew05@gmail.com>
Date: Tue, 1 Feb 2022 19:54:15 +0530
Subject: [PATCH 01/23] base: introduce app lock [1/4]

Signed-off-by: jhonboy121 <alfredmathew05@gmail.com>
---
 core/java/android/app/AppLockManager.java     | 159 ++++
 .../android/app/IAppLockManagerService.aidl   |  38 +
 .../android/app/SystemServiceRegistry.java    |  11 +
 core/java/android/content/Context.java        |   9 +
 .../notification/StatusBarNotification.java   |  30 +-
 core/res/AndroidManifest.xml                  |   8 +
 core/res/res/values/miku_config.xml           |   4 +
 core/res/res/values/miku_strings.xml          |  19 +
 core/res/res/values/miku_symbols.xml          |   4 +
 .../NotificationRemoteInputManager.java       |   3 +-
 .../NotificationViewHierarchyManager.java     |   6 +-
 .../inflation/NotificationRowBinderImpl.java  |   3 +-
 .../row/ExpandableNotificationRow.java        |  26 +-
 .../phone/StatusBarNotificationPresenter.java |   4 +
 services/core/Android.bp                      |   8 +-
 .../com/android/server/app/AppLockConfig.kt   | 175 ++++
 .../server/app/AppLockManagerService.kt       | 824 ++++++++++++++++++
 .../app/AppLockManagerServiceInternal.kt      |  87 ++
 .../android/server/app/BiometricUnlocker.kt   |  96 ++
 .../locksettings/LockSettingsService.java     |   2 +
 .../server/notification/BubbleExtractor.java  |   4 +-
 .../NotificationManagerInternal.java          |   2 +
 .../NotificationManagerService.java           |  57 +-
 .../notification/NotificationRecord.java      |  10 +
 .../server/wm/ActivityTaskManagerService.java | 104 ++-
 .../java/com/android/server/SystemServer.java |   7 +
 26 files changed, 1673 insertions(+), 27 deletions(-)
 create mode 100644 core/java/android/app/AppLockManager.java
 create mode 100644 core/java/android/app/IAppLockManagerService.aidl
 create mode 100644 core/res/res/values/miku_strings.xml
 create mode 100644 services/core/java/com/android/server/app/AppLockConfig.kt
 create mode 100644 services/core/java/com/android/server/app/AppLockManagerService.kt
 create mode 100644 services/core/java/com/android/server/app/AppLockManagerServiceInternal.kt
 create mode 100644 services/core/java/com/android/server/app/BiometricUnlocker.kt

diff --git a/core/java/android/app/AppLockManager.java b/core/java/android/app/AppLockManager.java
new file mode 100644
index 000000000000..8320786bbf07
--- /dev/null
+++ b/core/java/android/app/AppLockManager.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2022 AOSP-Krypton Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import android.Manifest;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.annotation.SystemService;
+import android.annotation.RequiresPermission;
+import android.annotation.UserHandleAware;
+import android.content.Context;
+import android.os.RemoteException;
+
+import java.util.concurrent.TimeUnit;
+import java.util.List;
+
+@SystemService(Context.APP_LOCK_SERVICE)
+public final class AppLockManager {
+
+    public static final long APP_LOCK_TIMEOUT_DEFAULT = 10 * 1000;
+
+    private final Context mContext;
+    private final IAppLockManagerService mService;
+
+    AppLockManager(Context context, IAppLockManagerService service) {
+        mContext = context;
+        mService = service;
+    }
+
+    /**
+     * Add an application to be protected. Package should be an user
+     * installed application or a system app whitelisted in
+     * {@link config_appLockAllowedSystemApps}.
+     * Caller must hold {@link android.permission.MANAGE_APP_LOCK}.
+     *
+     * @param packageName the package name of the app to add.
+     */
+    @UserHandleAware
+    @RequiresPermission(Manifest.permission.MANAGE_APP_LOCK)
+    public void addPackage(@NonNull String packageName) {
+        try {
+            mService.addPackage(packageName, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * Remove an application from the protected packages list.
+     * Caller must hold {@link android.permission.MANAGE_APP_LOCK}.
+     *
+     * @param packageName the package name of the app to remove.
+     */
+    @UserHandleAware
+    @RequiresPermission(Manifest.permission.MANAGE_APP_LOCK)
+    public void removePackage(@NonNull String packageName) {
+        try {
+            mService.removePackage(packageName, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * Get the current auto lock timeout.
+     *
+     * @param userId the user id given by the caller.
+     * @return the timeout in milliseconds if configuration for
+     *     current user exists, -1 otherwise.
+     */
+    @UserHandleAware
+    public long getTimeout() {
+        try {
+            return mService.getTimeout(mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * Set auto lock timeout.
+     * Caller must hold {@link android.permission.MANAGE_APP_LOCK}.
+     *
+     * @param timeout the timeout in milliseconds. Must be >= 5.
+     * @param userId the user id given by the caller.
+     */
+    @UserHandleAware
+    @RequiresPermission(Manifest.permission.MANAGE_APP_LOCK)
+    public void setTimeout(long timeout) {
+        try {
+            mService.setTimeout(timeout, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * Get the list of packages protected with app lock.
+     * Caller must hold {@link android.permission.MANAGE_APP_LOCK}.
+     *
+     * @return a list of package name of the protected apps.
+     */
+    @UserHandleAware
+    @NonNull
+    @RequiresPermission(Manifest.permission.MANAGE_APP_LOCK)
+    public List<String> getPackages() {
+        try {
+            return mService.getPackages(mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * Set whether notification content should be hidden for a package.
+     *
+     * @param packageName the package name.
+     * @param secure true to hide notification content.
+     */
+    @UserHandleAware
+    public void setSecureNotification(@NonNull String packageName, boolean secure) {
+        try {
+            mService.setSecureNotification(packageName, secure, mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * Get the list of packages whose notifications contents are secure.
+     * Caller must hold {@link android.permission.MANAGE_APP_LOCK}.
+     *
+     * @return a list of package names with secure notifications.
+     */
+    @UserHandleAware
+    @NonNull
+    @RequiresPermission(Manifest.permission.MANAGE_APP_LOCK)
+    public List<String> getPackagesWithSecureNotifications() {
+        try {
+            return mService.getPackagesWithSecureNotifications(mContext.getUserId());
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+}
\ No newline at end of file
diff --git a/core/java/android/app/IAppLockManagerService.aidl b/core/java/android/app/IAppLockManagerService.aidl
new file mode 100644
index 000000000000..8c1bc3b922db
--- /dev/null
+++ b/core/java/android/app/IAppLockManagerService.aidl
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2022 AOSP-Krypton Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+/**
+ * Interface for managing app lock.
+ * @hide
+ */
+interface IAppLockManagerService {
+
+    void addPackage(in String packageName, in int userId);
+
+    void removePackage(in String packageName, in int userId);
+
+    long getTimeout(in int userId);
+
+    void setTimeout(in long timeout, in int userId);
+
+    List<String> getPackages(in int userId);
+
+    void setSecureNotification(in String packageName, in boolean secure, in int userId);
+
+    List<String> getPackagesWithSecureNotifications(in int userId);
+}
\ No newline at end of file
diff --git a/core/java/android/app/SystemServiceRegistry.java b/core/java/android/app/SystemServiceRegistry.java
index e727b78e8add..7975a5bf952c 100644
--- a/core/java/android/app/SystemServiceRegistry.java
+++ b/core/java/android/app/SystemServiceRegistry.java
@@ -1470,6 +1470,17 @@ public final class SystemServiceRegistry {
                         return new DisplayHashManager();
                     }});
 
+        registerService(Context.APP_LOCK_SERVICE, AppLockManager.class,
+                new CachedServiceFetcher<AppLockManager>() {
+                    @Override
+                    public AppLockManager createService(ContextImpl ctx)
+                            throws ServiceNotFoundException {
+                        IBinder binder = ServiceManager.getServiceOrThrow(
+                                Context.APP_LOCK_SERVICE);
+                        return new AppLockManager(ctx,
+                            IAppLockManagerService.Stub.asInterface(binder));
+                    }});
+
         sInitializing = true;
         try {
             // Note: the following functions need to be @SystemApis, once they become mainline
diff --git a/core/java/android/content/Context.java b/core/java/android/content/Context.java
index c3ec09466de6..7306b8ad8c03 100644
--- a/core/java/android/content/Context.java
+++ b/core/java/android/content/Context.java
@@ -37,6 +37,7 @@ import android.annotation.TestApi;
 import android.annotation.UiContext;
 import android.annotation.UserIdInt;
 import android.app.ActivityManager;
+import android.app.AppLockManager;
 import android.app.GameManager;
 import android.app.IApplicationThread;
 import android.app.IServiceConnection;
@@ -5680,6 +5681,14 @@ public abstract class Context {
      */
     public static final String DISPLAY_HASH_SERVICE = "display_hash";
 
+    /**
+     * Use with {@link #getSystemService(String)} to retrieve a
+     * {@link AppLockManager}.
+     *
+     * @see #getSystemService(String)
+     */
+    public static final String APP_LOCK_SERVICE = "app_lock";
+
     /**
      * Determine whether the given permission is allowed for a particular
      * process and user ID running in the system.
diff --git a/core/java/android/service/notification/StatusBarNotification.java b/core/java/android/service/notification/StatusBarNotification.java
index 40041486f6a6..b38c387e53b2 100644
--- a/core/java/android/service/notification/StatusBarNotification.java
+++ b/core/java/android/service/notification/StatusBarNotification.java
@@ -71,10 +71,13 @@ public class StatusBarNotification implements Parcelable {
 
     private Context mContext; // used for inflation & icon expansion
 
+    private boolean mIsContentSecure;
+
     /** @hide */
     public StatusBarNotification(String pkg, String opPkg, int id,
             String tag, int uid, int initialPid, Notification notification, UserHandle user,
-            String overrideGroupKey, long postTime) {
+            String overrideGroupKey, long postTime,
+            boolean isContentSecure) {
         if (pkg == null) throw new NullPointerException();
         if (notification == null) throw new NullPointerException();
 
@@ -90,6 +93,7 @@ public class StatusBarNotification implements Parcelable {
         this.overrideGroupKey = overrideGroupKey;
         this.key = key();
         this.groupKey = groupKey();
+        mIsContentSecure = isContentSecure;
     }
 
     /**
@@ -129,6 +133,7 @@ public class StatusBarNotification implements Parcelable {
         this.notification = new Notification(in);
         this.user = UserHandle.readFromParcel(in);
         this.postTime = in.readLong();
+        mIsContentSecure = in.readBoolean();
         if (in.readInt() != 0) {
             this.overrideGroupKey = in.readString();
         }
@@ -198,6 +203,7 @@ public class StatusBarNotification implements Parcelable {
         this.notification.writeToParcel(out, flags);
         user.writeToParcel(out, flags);
         out.writeLong(this.postTime);
+        out.writeBoolean(mIsContentSecure);
         if (this.overrideGroupKey != null) {
             out.writeInt(1);
             out.writeString(this.overrideGroupKey);
@@ -249,7 +255,8 @@ public class StatusBarNotification implements Parcelable {
     StatusBarNotification cloneShallow(Notification notification) {
         StatusBarNotification result = new StatusBarNotification(this.pkg, this.opPkg,
                 this.id, this.tag, this.uid, this.initialPid,
-                notification, this.user, this.overrideGroupKey, this.postTime);
+                notification, this.user, this.overrideGroupKey,
+                this.postTime, mIsContentSecure);
         result.setInstanceId(this.mInstanceId);
         return result;
     }
@@ -523,4 +530,23 @@ public class StatusBarNotification implements Parcelable {
         return logTag.substring(0, MAX_LOG_TAG_LENGTH - hash.length() - 1) + "-"
                 + hash;
     }
+
+    /**
+     * Set whether the notification content is secure.
+     *
+     * @param isContentSecure whether the content is secure.
+     * @hide
+     */
+    public void setIsContentSecure(boolean isContentSecure) {
+        mIsContentSecure = isContentSecure;
+    }
+
+    /**
+     * Check whether the notification content is secure.
+     *
+     * @return true if content is secure, false otherwise.
+     */
+    public boolean getIsContentSecure() {
+        return mIsContentSecure;
+    }
 }
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index 0aa8de740bf0..40415db63702 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -708,6 +708,9 @@
     <protected-broadcast android:name="android.app.action.SCHEDULE_EXACT_ALARM_PERMISSION_STATE_CHANGED" />
     <protected-broadcast android:name="android.app.action.ACTION_SHOW_NEW_USER_DISCLAIMER" />
 
+    <!-- App lock -->
+    <protected-broadcast android:name="com.android.server.app.AppLockManagerService.APP_LOCK_TIMEOUT" />
+
     <!-- ====================================================================== -->
     <!--                          RUNTIME PERMISSIONS                           -->
     <!-- ====================================================================== -->
@@ -5806,6 +5809,11 @@
     <permission android:name="android.permission.READ_GLOBAL_APP_SEARCH_DATA"
                 android:protectionLevel="internal|role" />
 
+    <!-- Allows an application to manage app lock
+         @hide -->
+    <permission android:name="android.permission.MANAGE_APP_LOCK"
+                android:protectionLevel="signature|privileged" />
+
     <!-- Attribution for Geofencing service. -->
     <attribution android:tag="GeofencingService" android:label="@string/geofencing_service"/>
     <!-- Attribution for Country Detector. -->
diff --git a/core/res/res/values/miku_config.xml b/core/res/res/values/miku_config.xml
index 748c2378ac5c..1fd294081898 100644
--- a/core/res/res/values/miku_config.xml
+++ b/core/res/res/values/miku_config.xml
@@ -25,5 +25,9 @@
 
      <!-- Whether to cleanup fingerprints upon connection to the daemon and when user switches -->
      <bool name="config_cleanupUnusedFingerprints">true</bool>
+    
+     <!-- List of system apps that are allowed to be locked with app lock.
+          Use with extreme caution. -->
+     <string-array name="config_appLockAllowedSystemApps" translatable="false">
 
 </resources>
diff --git a/core/res/res/values/miku_strings.xml b/core/res/res/values/miku_strings.xml
new file mode 100644
index 000000000000..58fb7160a956
--- /dev/null
+++ b/core/res/res/values/miku_strings.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright 2021 Miku UI
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+          http://www.apache.org/licenses/LICENSE-2.0
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <!-- App lock -->
+    <string name="unlock_application">Unlock <xliff:g id="label" example="Telegram">%1$s</xliff:g></string>
+
+</resources>
\ No newline at end of file
diff --git a/core/res/res/values/miku_symbols.xml b/core/res/res/values/miku_symbols.xml
index 8f31eacf145f..774682b511af 100644
--- a/core/res/res/values/miku_symbols.xml
+++ b/core/res/res/values/miku_symbols.xml
@@ -33,4 +33,8 @@
   <!-- QQS Height -->
   <java-symbol type="dimen" name="quick_qs_total_height" />
 
+  <!-- App lock -->
+  <java-symbol type="string" name="unlock_application" />
+  <java-symbol type="array" name="config_appLockAllowedSystemApps" />
+
 </resources>
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/NotificationRemoteInputManager.java b/packages/SystemUI/src/com/android/systemui/statusbar/NotificationRemoteInputManager.java
index 4552138761c0..015b6230b85d 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/NotificationRemoteInputManager.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/NotificationRemoteInputManager.java
@@ -683,7 +683,8 @@ public class NotificationRemoteInputManager implements Dumpable {
                 newNotification,
                 sbn.getUser(),
                 sbn.getOverrideGroupKey(),
-                sbn.getPostTime());
+                sbn.getPostTime(),
+                sbn.getIsContentSecure());
     }
 
     @Override
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/NotificationViewHierarchyManager.java b/packages/SystemUI/src/com/android/systemui/statusbar/NotificationViewHierarchyManager.java
index 396d86bab825..ab2b725a35a2 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/NotificationViewHierarchyManager.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/NotificationViewHierarchyManager.java
@@ -176,13 +176,15 @@ public class NotificationViewHierarchyManager implements DynamicPrivacyControlle
                     || !mLockscreenUserManager.needsSeparateWorkChallenge(userId))) {
                 userPublic = false;
             }
-            boolean needsRedaction = mLockscreenUserManager.needsRedaction(ent);
+            final boolean hideContents = ent.getSbn().getIsContentSecure();
+            boolean needsRedaction = hideContents || mLockscreenUserManager.needsRedaction(ent);
             boolean sensitive = userPublic && needsRedaction;
             boolean deviceSensitive = devicePublic
                     && !mLockscreenUserManager.userAllowsPrivateNotificationsInPublic(
                     currentUserId);
-            ent.setSensitive(sensitive, deviceSensitive);
+            ent.setSensitive(sensitive, hideContents || deviceSensitive);
             ent.getRow().setNeedsRedaction(needsRedaction);
+            ent.getRow().setForceHideContents(hideContents);
             mLowPriorityInflationHelper.recheckLowPriorityViewAndInflate(ent, ent.getRow());
             boolean isChildInGroup = mGroupManager.isChildInGroup(ent);
 
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/notification/collection/inflation/NotificationRowBinderImpl.java b/packages/SystemUI/src/com/android/systemui/statusbar/notification/collection/inflation/NotificationRowBinderImpl.java
index e5425cfc8c93..b828dff61369 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/notification/collection/inflation/NotificationRowBinderImpl.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/notification/collection/inflation/NotificationRowBinderImpl.java
@@ -232,7 +232,8 @@ public class NotificationRowBinderImpl implements NotificationRowBinder {
 
         // TODO: Replace this API with RowContentBindParams directly. Also move to a separate
         // redaction controller.
-        row.setNeedsRedaction(mNotificationLockscreenUserManager.needsRedaction(entry));
+        row.setNeedsRedaction(mNotificationLockscreenUserManager.needsRedaction(entry)
+            || entry.getSbn().getIsContentSecure());
 
         params.rebindAllContentViews();
         mRowContentBindStage.requestRebind(entry, en -> {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/notification/row/ExpandableNotificationRow.java b/packages/SystemUI/src/com/android/systemui/statusbar/notification/row/ExpandableNotificationRow.java
index 73bb6cd9ba1c..94991719395a 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/notification/row/ExpandableNotificationRow.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/notification/row/ExpandableNotificationRow.java
@@ -353,6 +353,8 @@ public class ExpandableNotificationRow extends ActivatableNotificationView
     private float mTopRoundnessDuringExpandAnimation;
     private float mBottomRoundnessDuringExpandAnimation;
 
+    private boolean mForceHideContents = false;
+
     /**
      * Returns whether the given {@code statusBarNotification} is a system notification.
      * <b>Note</b>, this should be run in the background thread if possible as it makes multiple IPC
@@ -1990,12 +1992,15 @@ public class ExpandableNotificationRow extends ActivatableNotificationView
     private void updateChildrenVisibility() {
         boolean hideContentWhileLaunching = mExpandAnimationRunning && mGuts != null
                 && mGuts.isExposed();
-        mPrivateLayout.setVisibility(!mShowingPublic && !mIsSummaryWithChildren
+        mPrivateLayout.setVisibility(!mForceHideContents
+                && !mShowingPublic
+                && !mIsSummaryWithChildren
                 && !hideContentWhileLaunching ? VISIBLE : INVISIBLE);
         if (mChildrenContainer != null) {
-            mChildrenContainer.setVisibility(!mShowingPublic && mIsSummaryWithChildren
-                    && !hideContentWhileLaunching ? VISIBLE
-                    : INVISIBLE);
+            mChildrenContainer.setVisibility(!mForceHideContents
+                && !mShowingPublic
+                && mIsSummaryWithChildren
+                && !hideContentWhileLaunching ? VISIBLE : INVISIBLE);
         }
         // The limits might have changed if the view suddenly became a group or vice versa
         updateLimits();
@@ -2167,6 +2172,7 @@ public class ExpandableNotificationRow extends ActivatableNotificationView
     }
 
     public boolean isExpandable() {
+        if (mForceHideContents) return false;
         if (mIsSummaryWithChildren && !shouldShowPublic()) {
             return !mChildrenExpanded;
         }
@@ -2328,6 +2334,7 @@ public class ExpandableNotificationRow extends ActivatableNotificationView
 
     @Override
     public int getIntrinsicHeight() {
+        if (mForceHideContents) return getCollapsedHeight();
         if (isUserLocked()) {
             return getActualHeight();
         }
@@ -2564,7 +2571,7 @@ public class ExpandableNotificationRow extends ActivatableNotificationView
             }
             mPublicLayout.setAlpha(1f);
             mPrivateLayout.setAlpha(1f);
-            mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
+            mPublicLayout.setVisibility((mShowingPublic || mForceHideContents) ? VISIBLE : INVISIBLE);
             updateChildrenVisibility();
         } else {
             animateShowingPublic(delay, duration, mShowingPublic);
@@ -2618,7 +2625,7 @@ public class ExpandableNotificationRow extends ActivatableNotificationView
     }
 
     private boolean shouldShowPublic() {
-        return mSensitive && mHideSensitiveForIntrinsicHeight;
+        return mForceHideContents || (mSensitive && mHideSensitiveForIntrinsicHeight);
     }
 
     public void makeActionsVisibile() {
@@ -3174,6 +3181,13 @@ public class ExpandableNotificationRow extends ActivatableNotificationView
         }
     }
 
+    public void setForceHideContents(boolean forceHide) {
+        if (mForceHideContents == forceHide) return;
+        mForceHideContents = forceHide;
+        updateChildrenVisibility();
+        onNotificationUpdated();
+    }
+
     private static class NotificationViewState extends ExpandableViewState {
 
         @Override
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarNotificationPresenter.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarNotificationPresenter.java
index bd6ff72101f0..9e8effd6d776 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarNotificationPresenter.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarNotificationPresenter.java
@@ -509,6 +509,10 @@ public class StatusBarNotificationPresenter implements NotificationPresenter,
 
         @Override
         public boolean suppressAwakeInterruptions(NotificationEntry entry) {
+            final StatusBarNotification sbn = entry.getSbn();
+            if (sbn.getIsContentSecure()) {
+                return true;
+            }
             return isDeviceInVrMode();
         }
 
diff --git a/services/core/Android.bp b/services/core/Android.bp
index 55b982b40611..f5280fa1adde 100644
--- a/services/core/Android.bp
+++ b/services/core/Android.bp
@@ -19,7 +19,10 @@ filegroup {
 
 filegroup {
     name: "services.core-sources",
-    srcs: ["java/**/*.java"],
+    srcs: [
+        "java/**/*.java",
+        "java/**/*.kt",
+    ],
     exclude_srcs: [
         ":services.core-sources-am-wm",
     ],
@@ -161,6 +164,9 @@ java_library_static {
         "overlayable_policy_aidl-java",
         "SurfaceFlingerProperties",
         "com.android.sysprop.watchdog",
+        "kotlin-stdlib",
+        "kotlinx-coroutines-android",
+        "kotlinx-coroutines-core",
     ],
     javac_shard_size: 50,
 }
diff --git a/services/core/java/com/android/server/app/AppLockConfig.kt b/services/core/java/com/android/server/app/AppLockConfig.kt
new file mode 100644
index 000000000000..b46a3eb4f81a
--- /dev/null
+++ b/services/core/java/com/android/server/app/AppLockConfig.kt
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2022 AOSP-Krypton Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.app
+
+import android.app.AppLockManager
+import android.os.FileUtils
+import android.os.FileUtils.S_IRWXU
+import android.os.FileUtils.S_IRWXG
+import android.util.ArrayMap
+import android.util.ArraySet
+import android.util.Slog
+
+import java.io.File
+import java.io.IOException
+
+import org.json.JSONException
+import org.json.JSONObject
+
+/**
+ * Container for app lock configuration. Also handles logic of reading
+ * and writing configuration to disk, serialized as a JSON file.
+ * All operations must be synchronized with an external lock.
+ *
+ * @hide
+ */
+internal class AppLockConfig(dataDir: File) {
+
+    private val appLockDir = File(dataDir, APP_LOCK_DIR_NAME)
+    private val appLockConfigFile = File(appLockDir, APP_LOCK_CONFIG_FILE)
+
+    private val _appLockPackages = ArraySet<String>()
+    val appLockPackages: Set<String>
+        get() = _appLockPackages.toSet()
+
+    var appLockTimeout: Long = AppLockManager.APP_LOCK_TIMEOUT_DEFAULT
+
+    private val _packageNotificationMap = ArrayMap<String, Boolean>()
+    val packageNotificationMap: Map<String, Boolean>
+        get() = _packageNotificationMap.toMap()
+
+    init {
+        appLockDir.mkdirs()
+        FileUtils.setPermissions(appLockDir, S_IRWXU or S_IRWXG, -1, -1)
+    }
+
+    /**
+     * Add an application to [appLockPackages].
+     *
+     * @param packageName the package name of the application.
+     * @return true if package was added, false if already exists.
+     */
+    fun addPackage(packageName: String): Boolean {
+        return _appLockPackages.add(packageName)
+    }
+
+    /**
+     * Remove an application from [appLockPackages].
+     *
+     * @param packageName the package name of the application.
+     * @return true if package was removed, false otherwise.
+     */
+    fun removePackage(packageName: String): Boolean {
+        _packageNotificationMap.remove(packageName)
+        return _appLockPackages.remove(packageName)
+    }
+
+    /**
+     * Set notifications as protected or not for an application
+     * in [appLockPackages].
+     *
+     * @param packageName the package name of the application.
+     * @return true if config was changed, false otherwise.
+     */
+    fun setSecureNotification(packageName: String, secure: Boolean): Boolean {
+        if (!_appLockPackages.contains(packageName)) {
+            Slog.e(AppLockManagerService.TAG, "Attempt to set secure " +
+                "notification field for package that is not in list")
+            return false
+        }
+        if (_packageNotificationMap[packageName] == secure) return false
+        _packageNotificationMap[packageName] = secure
+        return true
+    }
+
+    /**
+     * Parse contents from [appLockConfigFile].
+     */
+    fun read() {
+        reset()
+        if (!appLockConfigFile.isFile) {
+            Slog.i(AppLockManagerService.TAG, "No configuration saved")
+            return
+        }
+        try {
+            appLockConfigFile.inputStream().bufferedReader().use {
+                val rootObject = JSONObject(it.readText())
+                appLockTimeout = rootObject.optLong(KEY_TIMEOUT, AppLockManager.APP_LOCK_TIMEOUT_DEFAULT)
+                val packageObject = rootObject.optJSONObject(KEY_PACKAGES) ?: return@use
+                packageObject.keys().forEach { pkg ->
+                    _appLockPackages.add(pkg)
+                    _packageNotificationMap[pkg] = packageObject.optJSONObject(pkg)
+                        ?.optBoolean(KEY_SECURE_NOTIFICATION, false) == true
+                }
+            }
+        } catch(e: IOException) {
+            Slog.wtf(AppLockManagerService.TAG, "Failed to read config file", e)
+        } catch(e: JSONException) {
+            Slog.wtf(AppLockManagerService.TAG, "Failed to parse config file", e)
+        }
+        if (AppLockManagerService.DEBUG) {
+            Slog.d(AppLockManagerService.TAG, "readConfig: packages = $appLockPackages")
+            Slog.d(AppLockManagerService.TAG, "readConfig: packageNotificationMap = $packageNotificationMap")
+            Slog.d(AppLockManagerService.TAG, "readConfig: timeout = $appLockTimeout")
+        }
+    }
+
+    private fun reset() {
+        _appLockPackages.clear()
+        appLockTimeout = AppLockManager.APP_LOCK_TIMEOUT_DEFAULT
+        _packageNotificationMap.clear()
+    }
+
+    /**
+     * Write contents to [appLockConfigFile].
+     */
+    fun write() {
+        val rootObject = JSONObject()
+        try {
+            rootObject.put(KEY_TIMEOUT, appLockTimeout)
+            val packageObject = JSONObject()
+            appLockPackages.forEach {
+                val packageConfigObject = JSONObject().apply {
+                    put(KEY_SECURE_NOTIFICATION, _packageNotificationMap[it] == true)
+                }
+                packageObject.put(it, packageConfigObject)
+            }
+            rootObject.put(KEY_PACKAGES, packageObject)
+        } catch(e: JSONException) {
+            Slog.wtf(AppLockManagerService.TAG, "Failed to create json configuration", e)
+            return
+        }
+        try {
+            appLockConfigFile.outputStream().bufferedWriter().use {
+                val flattenedString = rootObject.toString(4)
+                it.write(flattenedString, 0, flattenedString.length)
+                it.flush()
+            }
+        } catch(e: IOException) {
+            Slog.wtf(AppLockManagerService.TAG, "Failed to write config to file", e)
+        }
+    }
+
+    companion object {
+        private const val APP_LOCK_DIR_NAME = "app_lock"
+        private const val APP_LOCK_CONFIG_FILE = "app_lock_config.json"
+
+        private const val KEY_TIMEOUT = "timeout"
+        private const val KEY_PACKAGES = "packages"
+        private const val KEY_SECURE_NOTIFICATION = "secure_notification"
+    }
+}
\ No newline at end of file
diff --git a/services/core/java/com/android/server/app/AppLockManagerService.kt b/services/core/java/com/android/server/app/AppLockManagerService.kt
new file mode 100644
index 000000000000..08a9e06dda4e
--- /dev/null
+++ b/services/core/java/com/android/server/app/AppLockManagerService.kt
@@ -0,0 +1,824 @@
+/*
+ * Copyright (C) 2022 AOSP-Krypton Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.app
+
+import android.Manifest
+import android.annotation.RequiresPermission
+import android.app.ActivityManager
+import android.app.ActivityTaskManager
+import android.app.AlarmManager
+import android.app.IActivityTaskManager
+import android.app.IAppLockManagerService
+import android.app.KeyguardManager
+import android.app.PendingIntent
+import android.app.TaskStackListener
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import android.content.IntentFilter
+import android.content.pm.PackageManager
+import android.os.Binder
+import android.os.Environment
+import android.os.RemoteException
+import android.os.SystemClock
+import android.os.UserHandle
+import android.util.ArrayMap
+import android.util.ArraySet
+import android.util.Log
+import android.util.Slog
+
+import com.android.internal.annotations.GuardedBy
+import com.android.internal.R
+import com.android.server.app.AppLockManagerServiceInternal.CancelCallback
+import com.android.server.app.AppLockManagerServiceInternal.UnlockCallback
+import com.android.server.LocalServices
+import com.android.server.notification.NotificationManagerInternal
+import com.android.server.SystemService
+import com.android.server.wm.ActivityTaskManagerInternal
+
+import kotlin.random.Random
+
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.runBlocking
+import kotlinx.coroutines.sync.Mutex
+import kotlinx.coroutines.sync.withLock
+import kotlinx.coroutines.withContext
+
+/**
+ * Service to manage per app lock.
+ *
+ * @hide
+ */
+class AppLockManagerService(private val context: Context) :
+    IAppLockManagerService.Stub() {
+
+    private val alsInternal = LocalService()
+    private val serviceScope = CoroutineScope(Dispatchers.Default)
+
+    private var currentUserId = UserHandle.USER_NULL
+    private var isDeviceSecure = false
+
+    private val mutex = Mutex()
+
+    @GuardedBy("mutex")
+    private val userConfigMap = ArrayMap<Int, AppLockConfig>()
+
+    @GuardedBy("mutex")
+    private val topPackages = ArraySet<String>()
+
+    @GuardedBy("mutex")
+    private val unlockedPackages = ArraySet<String>()
+
+    private lateinit var biometricUnlocker: BiometricUnlocker
+    private lateinit var activityTaskManager: IActivityTaskManager
+    private lateinit var atmInternal: ActivityTaskManagerInternal
+    private lateinit var notificationManagerInternal: NotificationManagerInternal
+    private lateinit var keyguardManager: KeyguardManager
+    private lateinit var alarmManager: AlarmManager
+
+    private val alarmsMutex = Mutex()
+
+    @GuardedBy("alarmsMutex")
+    private val scheduledAlarms = ArrayMap<String, Pair<Int, PendingIntent>>()
+
+    // Using same request code for multiple pending intents will
+    // cause in timeout alarms to report wrong package, so we use
+    // randomized request codes and keep a set of used ones to
+    // prevent collisions. This set is cleared one by one when each
+    // alarm is received.
+    @GuardedBy("alarmsMutex")
+    private var usedAlarmRequestCodes = ArraySet<Int>()
+
+    private val whiteListedSystemApps = mutableListOf<String>()
+
+    // Sometimes onTaskStackChanged is called multiple times
+    // during app switches and [unlockInternal] might be called
+    // more than once for a locked package in [checkAndUnlockPackage].
+    // Cache the queued package name to prevent duplicate prompts.
+    @GuardedBy("mutex")
+    private var unlockScheduledPackage: String? = null
+
+    private lateinit var packageManager: PackageManager
+    private val packageChangeReceiver = object : BroadcastReceiver() {
+        override fun onReceive(context: Context?, intent: Intent?) {
+            if (intent?.action != Intent.ACTION_PACKAGE_REMOVED) return
+            val userId = getSendingUserId()
+            if (userId != currentUserId) {
+                logD("Ignoring package removal broadcast from user $userId")
+                return
+            }
+            val packageName = intent.data?.schemeSpecificPart ?: run {
+                Slog.e(TAG, "Failed to get package name")
+                return
+            }
+            serviceScope.launch {
+                val config = mutex.withLock {
+                    userConfigMap[userId] ?: run {
+                        Slog.e(TAG, "Config unavailable for user $userId")
+                        return@launch
+                    }
+                }
+                mutex.withLock {
+                    if (!config.appLockPackages.contains(packageName)) {
+                        logD("Package $packageName not in the list, ignoring")
+                        return@launch
+                    }
+                }
+                logD("Package $packageName uninstalled, cleaning up")
+                alarmsMutex.withLock {
+                    scheduledAlarms.remove(packageName)?.let {
+                        alarmManager.cancel(it.second)
+                        usedAlarmRequestCodes.remove(it.first)
+                    }
+                }
+                mutex.withLock {
+                    unlockedPackages.remove(packageName)
+                    if (config.removePackage(packageName)) {
+                        config.write()
+                    }
+                }
+            }
+        }
+    }
+
+    private val taskStackListener = object : TaskStackListener() {
+        override fun onTaskStackChanged() {
+            logD("onTaskStackChanged")
+            serviceScope.launch {
+                val currentTopPackages = ArraySet<String>()
+                atmInternal.getTopVisibleActivities().forEach {
+                    val packageName = atmInternal.getActivityName(
+                        it.activityToken)?.packageName ?: return@forEach
+                    currentTopPackages.add(packageName)
+                }
+                logD("topPackages = $topPackages")
+                logD("currentTopPackages = $currentTopPackages")
+                mutex.withLock {
+                    topPackages.filter {
+                        !currentTopPackages.contains(it) && unlockedPackages.contains(it)
+                    }.forEach {
+                        scheduleLockAlarm(it)
+                    }
+                    topPackages.clear()
+                    topPackages.addAll(currentTopPackages)
+                }
+                alarmsMutex.withLock {
+                    currentTopPackages.forEach { pkg ->
+                        if (!scheduledAlarms.containsKey(pkg)) return@forEach
+                        logD("Cancelling timeout alarm for $pkg")
+                        scheduledAlarms.remove(pkg)?.let {
+                            alarmManager.cancel(it.second)
+                            usedAlarmRequestCodes.remove(it.first)
+                        }
+                    }
+                }
+                currentTopPackages.forEach {
+                    checkAndUnlockPackage(it)
+                }
+            }
+        }
+    }
+
+    private val lockAlarmReceiver = object : BroadcastReceiver() {
+        override fun onReceive(context: Context?, intent: Intent?) {
+            logD("Lock alarm received")
+            if (intent?.action != ACTION_APP_LOCK_TIMEOUT) return
+            val packageName = intent.getStringExtra(EXTRA_PACKAGE) ?: return
+            logD("$packageName timed out")
+            serviceScope.launch {
+                mutex.withLock {
+                    if (topPackages.contains(packageName)) {
+                        logD("$packageName is currently in foreground, skipping lock")
+                        return@withLock
+                    }
+                    unlockedPackages.remove(packageName)
+                    notificationManagerInternal.updateSecureNotifications(
+                        packageName, true, ActivityManager.getCurrentUser())
+                }
+                alarmsMutex.withLock {
+                    scheduledAlarms.remove(packageName)?.let {
+                        usedAlarmRequestCodes.remove(it.first)
+                    }
+                }
+            }
+        }
+    }
+
+    private fun checkAndUnlockPackage(pkg: String) {
+        if (!isDeviceSecure) return
+        serviceScope.launch {
+            mutex.withLock {
+                if (unlockedPackages.contains(pkg)) return@launch
+                val config = userConfigMap[currentUserId] ?: run {
+                    Slog.e(TAG, "Config unavailable for user $currentUserId")
+                    return@launch
+                }
+                if (!config.appLockPackages.contains(pkg)) return@launch
+                if (unlockScheduledPackage == pkg) {
+                    logD("Unlock already scheduled for $pkg, skipping")
+                    return@launch
+                }
+                logD("$pkg is locked out, asking user to unlock")
+                unlockScheduledPackage = pkg
+            }
+            unlockInternal(pkg, currentUserId,
+                onSuccess = {
+                    serviceScope.launch {
+                        mutex.withLock {
+                            unlockedPackages.add(pkg)
+                            unlockScheduledPackage = null
+                        }
+                    }
+                },
+                onCancel = {
+                    serviceScope.launch {
+                        mutex.withLock {
+                            unlockScheduledPackage = null
+                        }
+                    }
+                    // Send user to home on cancel
+                    context.mainExecutor.execute {
+                        atmInternal.startHomeActivity(currentUserId,
+                            "unlockInternal#onCancel")
+                    }
+                }
+            )
+        }
+    }
+
+    private fun scheduleLockAlarm(pkg: String) {
+        logD("scheduleLockAlarm, package = $pkg")
+        serviceScope.launch {
+            alarmsMutex.withLock {
+                if (scheduledAlarms.containsKey(pkg)) {
+                    logD("Alarm already scheduled for package $pkg")
+                    return@launch
+                }
+            }
+            val timeout = mutex.withLock {
+                userConfigMap[currentUserId]?.appLockTimeout
+            } ?: run {
+                Slog.e(TAG, "Failed to retrieve user config for $currentUserId")
+                return@launch
+            }
+            val requestCode = alarmsMutex.withLock {
+                getRequestCodeLocked()
+            }
+            logD("requestCode = $requestCode, usedCodes = $usedAlarmRequestCodes")
+            val pendingIntent = PendingIntent.getBroadcast(
+                context,
+                requestCode,
+                Intent(ACTION_APP_LOCK_TIMEOUT).apply {
+                    putExtra(EXTRA_PACKAGE, pkg)
+                },
+                PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
+            )
+            alarmManager.setExactAndAllowWhileIdle(
+                AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                SystemClock.elapsedRealtime() + timeout,
+                pendingIntent
+            )
+            alarmsMutex.withLock {
+                scheduledAlarms[pkg] = Pair(requestCode, pendingIntent)
+            }
+        }
+    }
+
+    private fun getRequestCodeLocked(): Int {
+        var code = 0
+        while (usedAlarmRequestCodes.contains(code)) {
+            code = Random.nextInt(0, 1000)
+        }
+        usedAlarmRequestCodes.add(code)
+        return code
+    }
+
+    private fun getActualUserId(userId: Int, tag: String): Int {
+        return ActivityManager.handleIncomingUser(Binder.getCallingPid(),
+            Binder.getCallingUid(), userId, false /* allowAll */,
+            true /* requireFull */, tag, AppLockManagerService::class.qualifiedName)
+    }
+
+    private fun unlockInternal(
+        pkg: String,
+        userId: Int,
+        onSuccess: () -> Unit,
+        onCancel: () -> Unit,
+    ) {
+        val ident = Binder.clearCallingIdentity()
+        try {
+            if (!biometricUnlocker.canUnlock()) {
+                Slog.e(TAG, "Application cannot be unlocked with biometrics or device credentials")
+                return
+            }
+            biometricUnlocker.unlock(getLabelForPackage(pkg, userId), onSuccess, onCancel)
+        } finally {
+            Binder.restoreCallingIdentity(ident)
+        }
+    }
+
+    private fun getLabelForPackage(pkg: String, userId: Int): String? {
+        return try {
+            val aInfo = packageManager.getApplicationInfoAsUser(pkg,
+                PackageManager.MATCH_ALL, userId)
+            aInfo.loadLabel(packageManager).toString()
+        } catch(e: PackageManager.NameNotFoundException) {
+            Slog.e(TAG, "Package $pkg not found")
+            null
+        }
+    }
+
+    /**
+     * Add an application to be protected.
+     *
+     * @param packageName the package name of the app to add.
+     * @param userId the user id of the caller.
+     * @throws [SecurityException] if caller does not have permission
+     *     [Manifest.permissions.MANAGE_APP_LOCK].
+     * @throws [IllegalArgumentException] if package is a system app that
+     *     is not whitelisted in [R.array.config_appLockAllowedSystemApps],
+     *     or if package is not installed.
+     */
+    @RequiresPermission(Manifest.permission.MANAGE_APP_LOCK)
+    override fun addPackage(packageName: String, userId: Int) {
+        logD("addPackage: packageName = $packageName, userId = $userId")
+        enforceCallingPermission("addPackage")
+        checkPackage(packageName, userId)
+        val actualUserId = getActualUserId(userId, "addPackage")
+        serviceScope.launch {
+            mutex.withLock {
+                userConfigMap[actualUserId]?.let {
+                    if (it.addPackage(packageName)) {
+                        // Collapse any active notifications or bubbles for the app.
+                        if (!unlockedPackages.contains(packageName) &&
+                                !topPackages.contains(packageName)) {
+                            notificationManagerInternal.updateSecureNotifications(
+                                packageName, true, actualUserId)
+                        }
+                        withContext(Dispatchers.IO) {
+                            it.write()
+                        }
+                    }
+                } ?: Slog.e(TAG, "addPackage requested by unknown user id $actualUserId")
+            }
+        }
+    }
+
+    private fun checkPackage(pkg: String, userId: Int) {
+        try {
+            val aInfo = packageManager.getApplicationInfoAsUser(
+                pkg, PackageManager.MATCH_ALL, userId)
+            if (!aInfo.isSystemApp()) return
+            if (!whiteListedSystemApps.contains(pkg))
+                throw IllegalArgumentException("System package $pkg is not whitelisted")
+        } catch(e: PackageManager.NameNotFoundException) {
+            throw IllegalArgumentException("Package $pkg is not installed")
+        }
+    }
+
+    /**
+     * Remove an application from the protected packages list.
+     *
+     * @param packageName the package name of the app to remove.
+     * @param userId the user id of the caller.
+     * @throws [SecurityException] if caller does not have permission
+     *     [Manifest.permissions.MANAGE_APP_LOCK].
+     */
+    @RequiresPermission(Manifest.permission.MANAGE_APP_LOCK)
+    override fun removePackage(packageName: String, userId: Int) {
+        logD("removePackage: packageName = $packageName, userId = $userId")
+        enforceCallingPermission("removePackage")
+        val actualUserId = getActualUserId(userId, "removePackage")
+        serviceScope.launch {
+            mutex.withLock {
+                userConfigMap[actualUserId]?.let {
+                    if (it.removePackage(packageName)) {
+                        // Let active notifications be expanded since the app
+                        // is no longer protected.
+                        notificationManagerInternal.updateSecureNotifications(
+                            packageName, false, actualUserId)
+                        withContext(Dispatchers.IO) {
+                            it.write()
+                        }
+                    }
+                } ?: Slog.e(TAG, "removePackage requested by unknown user id $actualUserId")
+            }
+        }
+    }
+
+    /**
+     * Get the current auto lock timeout.
+     *
+     * @param userId the user id of the caller.
+     * @return the timeout in milliseconds if configuration for
+     *     current user exists, -1 otherwise.
+     */
+    @RequiresPermission(Manifest.permission.MANAGE_APP_LOCK)
+    override fun getTimeout(userId: Int): Long {
+        logD("getTimeout: userId = $userId")
+        val actualUserId = getActualUserId(userId, "getTimeout")
+        return runBlocking {
+            mutex.withLock {
+                userConfigMap[actualUserId]?.let { it.appLockTimeout } ?: run {
+                    Slog.e(TAG, "getTimeout requested by unknown user id $actualUserId")
+                    -1L
+                }
+            }
+        }
+    }
+
+    /**
+     * Set auto lock timeout.
+     *
+     * @param timeout the timeout in milliseconds. Must be >= 5.
+     * @param userId the user id of the caller.
+     * @throws [SecurityException] if caller does not have permission
+     *     [Manifest.permissions.MANAGE_APP_LOCK].
+     */
+    @RequiresPermission(Manifest.permission.MANAGE_APP_LOCK)
+    override fun setTimeout(timeout: Long, userId: Int) {
+        logD("setTimeout: timeout = $timeout, userId = $userId")
+        if (timeout < 5L) {
+            throw IllegalArgumentException("Timeout must be greater than or equal to 5")
+        }
+        enforceCallingPermission("setTimeout")
+        val actualUserId = getActualUserId(userId, "setTimeout")
+        serviceScope.launch {
+            mutex.withLock {
+                userConfigMap[actualUserId]?.let {
+                    if (it.appLockTimeout != timeout) {
+                        it.appLockTimeout = timeout
+                        it.write()
+                    }
+                } ?: Slog.e(TAG, "setTimeout requested by unknown user id $actualUserId")
+            }
+        }
+    }
+
+    /**
+     * Get the list of packages protected with app lock.
+     *
+     * @param userId the user id of the caller.
+     * @return list of package name of the protected apps.
+     * @throws [SecurityException] if caller does not have permission
+     *     [Manifest.permissions.MANAGE_APP_LOCK].
+     */
+    @RequiresPermission(Manifest.permission.MANAGE_APP_LOCK)
+    override fun getPackages(userId: Int): List<String> {
+        logD("getPackages: userId = $userId")
+        enforceCallingPermission("getPackages")
+        val actualUserId = getActualUserId(userId, "getPackages")
+        return runBlocking {
+            mutex.withLock {
+                userConfigMap[actualUserId]?.appLockPackages?.toList() ?: run {
+                    Slog.e(TAG, "getPackages requested by unknown user id $actualUserId")
+                    emptyList()
+                }
+            }
+        }
+    }
+
+    /**
+     * Set whether notification content should be hidden for a package.
+     *
+     * @param packageName the package name.
+     * @param secure true to hide notification content.
+     * @param userId the user id of the caller.
+     * @throws [SecurityException] if caller does not have permission
+     *     [Manifest.permissions.MANAGE_APP_LOCK].
+     */
+    override fun setSecureNotification(
+        packageName: String,
+        secure: Boolean,
+        userId: Int,
+    ) {
+        logD("setSecureNotification: packageName = $packageName, userId = $userId")
+        enforceCallingPermission("setSecureNotification")
+        val actualUserId = getActualUserId(userId, "setSecureNotification")
+        serviceScope.launch {
+            mutex.withLock {
+                val config = userConfigMap[actualUserId] ?: run {
+                    Slog.e(TAG, "setSecureNotification requested by unknown " +
+                        "user id $actualUserId")
+                    return@withLock
+                }
+                if (config.setSecureNotification(packageName, secure)) {
+                    notificationManagerInternal.updateSecureNotifications(
+                        packageName, secure, actualUserId)
+                    withContext(Dispatchers.IO) {
+                        config.write()
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Get the list of packages whose notifications contents are secure.
+     * Caller must hold {@link android.permission.MANAGE_APP_LOCK}.
+     *
+     * @param userId the user id of the caller.
+     * @return a list of package names with secure notifications.
+     * @throws [SecurityException] if caller does not have permission
+     *     [Manifest.permissions.MANAGE_APP_LOCK].
+     */
+    override fun getPackagesWithSecureNotifications(userId: Int): List<String> {
+        logD("getPackagesWithSecureNotifications: userId = $userId")
+        enforceCallingPermission("getPackagesWithSecureNotifications")
+        val actualUserId = getActualUserId(userId, "getPackagesWithSecureNotifications")
+        return runBlocking {
+            mutex.withLock {
+                val config = userConfigMap[actualUserId] ?: run {
+                    Slog.e(TAG, "getPackagesWithSecureNotifications requested by " +
+                        "unknown user id $actualUserId")
+                    return@withLock emptyList()
+                }
+                config.packageNotificationMap.entries.filter {
+                    it.value
+                }.map {
+                    it.key
+                }.toList()
+            }
+        }
+    }
+
+    private fun enforceCallingPermission(msg: String) {
+        context.enforceCallingPermission(Manifest.permission.MANAGE_APP_LOCK, msg)
+    }
+
+    private fun onStart() {
+        LocalServices.addService(AppLockManagerServiceInternal::class.java, alsInternal)
+    }
+
+    private fun onBootCompleted() {
+        Slog.i(TAG, "onBootCompleted")
+        whiteListedSystemApps.addAll(context.resources
+            .getStringArray(R.array.config_appLockAllowedSystemApps).toList())
+
+        alarmManager = context.getSystemService(AlarmManager::class.java)
+        context.registerReceiverAsUser(
+            lockAlarmReceiver,
+            UserHandle.SYSTEM,
+            IntentFilter(ACTION_APP_LOCK_TIMEOUT),
+            null /* broadcastPermission */,
+            null /* scheduler */,
+        )
+
+        packageManager = context.packageManager
+        context.registerReceiverForAllUsers(
+            packageChangeReceiver,
+            IntentFilter(Intent.ACTION_PACKAGE_REMOVED),
+            null /* broadcastPermission */,
+            null /* scheduler */,
+        )
+
+        biometricUnlocker = BiometricUnlocker(context)
+
+        keyguardManager = context.getSystemService(KeyguardManager::class.java)
+
+        notificationManagerInternal = LocalServices.getService(NotificationManagerInternal::class.java)
+
+        activityTaskManager = ActivityTaskManager.getService()
+        atmInternal = LocalServices.getService(ActivityTaskManagerInternal::class.java)
+        activityTaskManager.registerTaskStackListener(taskStackListener)
+    }
+
+    private fun onUserStarting(userId: Int) {
+        Slog.i(TAG, "onUserStarting: userId = $userId")
+        currentUserId = userId
+        isDeviceSecure = keyguardManager.isDeviceSecure(userId)
+        logD("isDeviceSecure = $isDeviceSecure")
+        serviceScope.launch {
+            mutex.withLock {
+                if (!userConfigMap.containsKey(userId)) {
+                    val config = AppLockConfig(Environment.getDataSystemDeDirectory(userId))
+                    userConfigMap[userId] = config
+                    withContext(Dispatchers.IO) {
+                        config.read()
+                    }
+                }
+            }
+        }
+    }
+
+    private fun onUserStopping(userId: Int): Job {
+        Slog.i(TAG, "onUserStopping: userId = $userId")
+        return serviceScope.launch {
+            mutex.withLock {
+                val config = userConfigMap[userId] ?: return@withLock
+                userConfigMap.remove(userId)
+                unlockedPackages.clear()
+                withContext(Dispatchers.IO) {
+                    config.write()
+                }
+            }
+        }
+    }
+
+    private fun onUserSwitching(oldUserId: Int, newUserId: Int) {
+        Slog.i(TAG, "onUserSwitching: oldUserId = $oldUserId, newUserId = $newUserId")
+        serviceScope.launch {
+            if (oldUserId != UserHandle.USER_NULL) {
+                onUserStopping(oldUserId).join()
+            }
+            onUserStarting(newUserId)
+        }
+    }
+
+    private inner class LocalService : AppLockManagerServiceInternal() {
+        override fun requireUnlock(packageName: String, userId: Int): Boolean {
+            return requireUnlockInternal(packageName, userId, false)
+        }
+
+        private fun requireUnlockInternal(
+            packageName: String,
+            userId: Int,
+            ignoreLockState: Boolean,
+        ): Boolean {
+            if (userId < 0) {
+                Slog.w(TAG, "Ignoring requireUnlock call for special user $userId")
+                return false
+            }
+            if (!isDeviceSecure) {
+                logD("Device is not secure, app does not require unlock")
+                return false
+            }
+            // If device is locked then there is no point in proceeding.
+            if (!ignoreLockState && keyguardManager.isDeviceLocked()) {
+                logD("Device is locked, app does not require unlock")
+                return false
+            }
+            logD("requireUnlock: packageName = $packageName")
+            val actualUserId = getActualUserId(userId, "requireUnlock")
+            return runBlocking {
+                mutex.withLock {
+                    val config = userConfigMap[actualUserId] ?: run {
+                        Slog.e(TAG, "requireUnlock queried by unknown user id $actualUserId")
+                        return@withLock false
+                    }
+                    if (config.appLockPackages.contains(packageName)) {
+                        val requireUnlock = !unlockedPackages.contains(packageName)
+                        logD("requireUnlock = $requireUnlock")
+                        requireUnlock
+                    } else {
+                        false
+                    }
+                }
+            }
+        }
+
+        override fun unlock(
+            packageName: String,
+            unlockCallback: UnlockCallback?,
+            cancelCallback: CancelCallback?,
+            userId: Int
+        ) {
+            if (userId < 0) {
+                Slog.w(TAG, "Ignoring unlock call for special user $userId")
+                return
+            }
+            if (!isDeviceSecure) {
+                Slog.w(TAG, "Device is not secure, should not be " +
+                    "calling unlock()")
+                return
+            }
+            logD("unlock: packageName = $packageName")
+            val actualUserId = getActualUserId(userId, "unlock")
+            serviceScope.launch {
+                mutex.withLock {
+                    val config = userConfigMap[actualUserId] ?: run {
+                        Slog.e(TAG, "Unlock requested by unknown user id " +
+                            "$actualUserId")
+                        return@withLock
+                    }
+                    if (!config.appLockPackages.contains(packageName)) {
+                        Slog.w(TAG, "Unlock requested for package $packageName " +
+                            "that is not in list")
+                        return@withLock
+                    }
+                    unlockInternal(packageName, actualUserId,
+                        onSuccess = {
+                            logD("Unlock successfull")
+                            serviceScope.launch {
+                                mutex.withLock {
+                                    unlockedPackages.add(packageName)
+                                }
+                                unlockCallback?.onUnlocked(packageName)
+                                notificationManagerInternal.updateSecureNotifications(
+                                    packageName, false, actualUserId)
+                            }
+                        },
+                        onCancel = {
+                            logD("Unlock cancelled")
+                            serviceScope.launch {
+                                cancelCallback?.onCancelled(packageName)
+                            }
+                        }
+                    )
+                }
+            }
+        }
+
+        override fun reportPasswordChanged(userId: Int) {
+            if (userId < 0) {
+                Slog.w(TAG, "Ignoring reportPasswordChanged call for special user $userId")
+                return
+            }
+            logD("reportPasswordChanged: userId = $userId")
+            if (userId != currentUserId) {
+                logD("Ignoring password change event for user $userId")
+                return
+            }
+            isDeviceSecure = keyguardManager.isDeviceSecure(userId)
+            logD("isDeviceSecure = $isDeviceSecure")
+        }
+
+        override fun isNotificationSecured(
+            packageName: String,
+            userId: Int,
+        ): Boolean {
+            if (userId < 0) {
+                Slog.w(TAG, "Ignoring isNotificationSecured call for special user $userId")
+                return false
+            }
+            logD("isNotificationSecured: " +
+                    "packageName = $packageName, " +
+                    "userId = $userId")
+            val actualUserId = getActualUserId(userId, "isNotificationSecured")
+            if (!requireUnlockInternal(packageName, userId, true /* ignoreLockState */)) return false
+            return runBlocking {
+                mutex.withLock {
+                    val config = userConfigMap[actualUserId] ?: run {
+                        Slog.e(TAG, "isNotificationSecured queried by " +
+                            "unknown user id $actualUserId")
+                        return@withLock false
+                    }
+                    val secure = config.packageNotificationMap[packageName] == true
+                    logD("Secure = $secure")
+                    return@withLock secure
+                }
+            }
+        }
+    }
+
+    class Lifecycle(context: Context): SystemService(context) {
+        private lateinit var service: AppLockManagerService
+
+        override fun onStart() {
+            service = AppLockManagerService(context)
+            publishBinderService(Context.APP_LOCK_SERVICE, service)
+            service.onStart()
+        }
+
+        override fun onBootPhase(phase: Int) {
+            if (phase == PHASE_ACTIVITY_MANAGER_READY) {
+                service.onBootCompleted()
+            }
+        }
+
+        override fun onUserStarting(user: TargetUser) {
+            service.onUserStarting(user.userIdentifier)
+        }
+
+        override fun onUserStopping(user: TargetUser) {
+            service.onUserStopping(user.userIdentifier)
+        }
+
+        override fun onUserSwitching(from: TargetUser?, to: TargetUser) {
+            service.onUserSwitching(
+                from?.userIdentifier ?: UserHandle.USER_NULL,
+                to.userIdentifier
+            )
+        }
+    }
+
+    companion object {
+        internal const val TAG = "AppLockManagerService"
+        internal val DEBUG: Boolean
+            get() = Log.isLoggable(TAG, Log.DEBUG)
+
+        private const val ACTION_APP_LOCK_TIMEOUT = "com.android.server.app.AppLockManagerService.APP_LOCK_TIMEOUT"
+        private const val EXTRA_PACKAGE = "com.android.server.app.AppLockManagerService.PACKAGE"
+
+        internal fun logD(msg: String) {
+            if (DEBUG) Slog.d(TAG, msg)
+        }
+    }
+}
\ No newline at end of file
diff --git a/services/core/java/com/android/server/app/AppLockManagerServiceInternal.kt b/services/core/java/com/android/server/app/AppLockManagerServiceInternal.kt
new file mode 100644
index 000000000000..4e790617d206
--- /dev/null
+++ b/services/core/java/com/android/server/app/AppLockManagerServiceInternal.kt
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2022 AOSP-Krypton Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.app
+
+/**
+ * Internal class for system server to manage app lock.
+ *
+ * @hide
+ */
+abstract class AppLockManagerServiceInternal {
+
+    /**
+     * Whether user has to unlock this application in order to
+     * open it.
+     *
+     * @param packageName the package name of the app to check.
+     * @param userId the user id given by the caller.
+     * @return true if user has to unlock, false otherwise.
+     */
+    abstract fun requireUnlock(packageName: String, userId: Int): Boolean
+
+    /**
+     * Unlock the application.
+     *
+     * @param packageName the package name of the app to unlock.
+     * @param unlockCallback the callback to listen for when user unlocks.
+     * @param cancelCallback the callback to listen for when user cancels unlock.
+     * @param userId the user id given by the caller.
+     */
+    abstract fun unlock(
+        packageName: String,
+        unlockCallback: UnlockCallback?,
+        cancelCallback: CancelCallback?,
+        userId: Int,
+    )
+
+    /**
+     * Report that password for user has changed.
+     *
+     * @param userId the user for which password has changed.
+     */
+    abstract fun reportPasswordChanged(userId: Int)
+
+    /**
+     * Check whether notification content should be hidden for a package.
+     *
+     * @param packageName the package to check for.
+     * @param userId the user id given by the caller.
+     * @return true if notification should be hidden, false otherwise.
+     */
+    abstract fun isNotificationSecured(packageName: String, userId: Int): Boolean
+
+    @FunctionalInterface
+    interface UnlockCallback {
+        /**
+         * Callback fired when user successfully unlocks the security prompt.
+         *
+         * @param packageName the name of the package that was unlocked.
+         */
+        fun onUnlocked(packageName: String)
+    }
+
+    @FunctionalInterface
+    interface CancelCallback {
+        /**
+         * Callback fired when user cancells security prompt.
+         *
+         * @param packageName the name of the package for which the
+         *    unlock was cancelled.
+         */
+        fun onCancelled(packageName: String)
+    }
+}
\ No newline at end of file
diff --git a/services/core/java/com/android/server/app/BiometricUnlocker.kt b/services/core/java/com/android/server/app/BiometricUnlocker.kt
new file mode 100644
index 000000000000..294a4c7aa35a
--- /dev/null
+++ b/services/core/java/com/android/server/app/BiometricUnlocker.kt
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2022 AOSP-Krypton Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.app
+
+import android.content.Context
+import android.hardware.biometrics.BiometricConstants
+import android.hardware.biometrics.BiometricManager
+import android.hardware.biometrics.BiometricManager.Authenticators
+import android.hardware.biometrics.BiometricPrompt
+import android.hardware.biometrics.BiometricPrompt.AuthenticationCallback
+import android.hardware.biometrics.BiometricPrompt.AuthenticationResult
+import android.os.CancellationSignal
+import android.util.Slog
+
+import com.android.internal.R
+
+/**
+ * Handles logic of unlocking an app with biometrics or device credentials.
+ *
+ * @hide
+ */
+internal class BiometricUnlocker(private val context: Context) {
+
+    private val biometricManager = context.getSystemService(BiometricManager::class.java)
+
+    /**
+     * Determine whether biometrics or device credentials can be used for
+     * unlocking operation.
+     */
+    fun canUnlock(): Boolean =
+        biometricManager.canAuthenticate(
+            Authenticators.BIOMETRIC_STRONG or
+                Authenticators.DEVICE_CREDENTIAL
+        ) == BiometricManager.BIOMETRIC_SUCCESS
+
+    /**
+     * Unlock an application. Should call this method only if
+     * [canUnlock] returned true.
+     *
+     * @param title the title of the dialog prompt.
+     * @param onSuccess the callback invoked on successfull authentication.
+     * @param onCancel the callback invoked when authentication is cancelled.
+     */
+    fun unlock(
+        packageLabel: String?,
+        onSuccess: () -> Unit,
+        onCancel: () -> Unit,
+    ) {
+        val callback = object : AuthenticationCallback() {
+            override fun onAuthenticationSucceeded(result: AuthenticationResult) {
+                AppLockManagerService.logD("onAuthenticationSucceeded")
+                onSuccess()
+            }
+
+            override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
+                Slog.i(AppLockManagerService.TAG, "onAuthenticationError, errorCode = " +
+                    "$errorCode, errString = $errString")
+                if (errorCode == BiometricConstants.BIOMETRIC_ERROR_USER_CANCELED) {
+                    onCancel()
+                }
+            }
+        }
+        showCredentialsPrompt(
+            context.getString(R.string.unlock_application, packageLabel),
+            callback
+        )
+    }
+
+    private fun showCredentialsPrompt(
+        title: String,
+        callback: AuthenticationCallback,
+    ) {
+        BiometricPrompt.Builder(context)
+            .setTitle(title)
+            .setAllowedAuthenticators(
+                Authenticators.BIOMETRIC_STRONG or
+                    Authenticators.DEVICE_CREDENTIAL
+            )
+            .build()
+            .authenticate(CancellationSignal(), context.mainExecutor, callback)
+    }
+}
\ No newline at end of file
diff --git a/services/core/java/com/android/server/locksettings/LockSettingsService.java b/services/core/java/com/android/server/locksettings/LockSettingsService.java
index 7d5b7e535ca9..15e68c1ee5cf 100644
--- a/services/core/java/com/android/server/locksettings/LockSettingsService.java
+++ b/services/core/java/com/android/server/locksettings/LockSettingsService.java
@@ -128,6 +128,7 @@ import com.android.internal.widget.LockSettingsInternal;
 import com.android.internal.widget.LockscreenCredential;
 import com.android.internal.widget.RebootEscrowListener;
 import com.android.internal.widget.VerifyCredentialResponse;
+import com.android.server.app.AppLockManagerServiceInternal;
 import com.android.server.LocalServices;
 import com.android.server.ServiceThread;
 import com.android.server.SystemService;
@@ -2409,6 +2410,7 @@ public class LockSettingsService extends ILockSettings.Stub {
         mHandler.post(() -> {
             mInjector.getDevicePolicyManager().reportPasswordChanged(userId);
             LocalServices.getService(WindowManagerInternal.class).reportPasswordChanged(userId);
+            LocalServices.getService(AppLockManagerServiceInternal.class).reportPasswordChanged(userId);
         });
     }
 
diff --git a/services/core/java/com/android/server/notification/BubbleExtractor.java b/services/core/java/com/android/server/notification/BubbleExtractor.java
index 41e067e57190..3a9cc80cf026 100644
--- a/services/core/java/com/android/server/notification/BubbleExtractor.java
+++ b/services/core/java/com/android/server/notification/BubbleExtractor.java
@@ -84,7 +84,8 @@ public class BubbleExtractor implements NotificationSignalExtractor {
         NotificationChannel recordChannel = record.getChannel();
         if (!userEnabledBubbles
                 || appPreference == BUBBLE_PREFERENCE_NONE
-                || !notifCanPresentAsBubble) {
+                || !notifCanPresentAsBubble
+                || record.getSbn().getIsContentSecure()) {
             record.setAllowBubble(false);
             if (!notifCanPresentAsBubble) {
                 // clear out bubble metadata since it can't be used
@@ -138,6 +139,7 @@ public class BubbleExtractor implements NotificationSignalExtractor {
      */
     @VisibleForTesting
     boolean canPresentAsBubble(NotificationRecord r) {
+        if (r.isBubbleUpSuppressedByAppLock()) return false;
         Notification notification = r.getNotification();
         Notification.BubbleMetadata metadata = notification.getBubbleMetadata();
         String pkg = r.getSbn().getPackageName();
diff --git a/services/core/java/com/android/server/notification/NotificationManagerInternal.java b/services/core/java/com/android/server/notification/NotificationManagerInternal.java
index 0528b95d1a6e..3935d3e0d3ca 100644
--- a/services/core/java/com/android/server/notification/NotificationManagerInternal.java
+++ b/services/core/java/com/android/server/notification/NotificationManagerInternal.java
@@ -36,4 +36,6 @@ public interface NotificationManagerInternal {
     void removeForegroundServiceFlagFromNotification(String pkg, int notificationId, int userId);
 
     void onConversationRemoved(String pkg, int uid, Set<String> shortcuts);
+
+    void updateSecureNotifications(String pkg, boolean isContentSecure, int userId);
 }
diff --git a/services/core/java/com/android/server/notification/NotificationManagerService.java b/services/core/java/com/android/server/notification/NotificationManagerService.java
index b86f7fed672f..60d270d22a69 100755
--- a/services/core/java/com/android/server/notification/NotificationManagerService.java
+++ b/services/core/java/com/android/server/notification/NotificationManagerService.java
@@ -34,6 +34,7 @@ import static android.app.NotificationManager.ACTION_NOTIFICATION_CHANNEL_GROUP_
 import static android.app.NotificationManager.ACTION_NOTIFICATION_LISTENER_ENABLED_CHANGED;
 import static android.app.NotificationManager.ACTION_NOTIFICATION_POLICY_ACCESS_GRANTED_CHANGED;
 import static android.app.NotificationManager.BUBBLE_PREFERENCE_ALL;
+import static android.app.NotificationManager.BUBBLE_PREFERENCE_NONE;
 import static android.app.NotificationManager.EXTRA_AUTOMATIC_ZEN_RULE_ID;
 import static android.app.NotificationManager.EXTRA_AUTOMATIC_ZEN_RULE_STATUS;
 import static android.app.NotificationManager.IMPORTANCE_LOW;
@@ -277,6 +278,7 @@ import com.android.internal.util.DumpUtils;
 import com.android.internal.util.Preconditions;
 import com.android.internal.util.XmlUtils;
 import com.android.internal.util.function.TriPredicate;
+import com.android.server.app.AppLockManagerServiceInternal;
 import com.android.server.DeviceIdleInternal;
 import com.android.server.EventLogTags;
 import com.android.server.IoThread;
@@ -621,6 +623,8 @@ public class NotificationManagerService extends SystemService {
     protected static final String ACTION_LEARNMORE_NAS =
             "android.server.notification.action.LEARNMORE_NAS";
 
+    private AppLockManagerServiceInternal mAppLockManagerService = null;
+
     static class Archive {
         final SparseArray<Boolean> mEnabled;
         final int mBufferSize;
@@ -2692,6 +2696,7 @@ public class NotificationManagerService extends SystemService {
             migrateDefaultNASShowNotificationIfNecessary();
         } else if (phase == SystemService.PHASE_ACTIVITY_MANAGER_READY) {
             mSnoozeHelper.scheduleRepostsForPersistedNotifications(System.currentTimeMillis());
+            mAppLockManagerService = LocalServices.getService(AppLockManagerServiceInternal.class);
         }
     }
 
@@ -3516,8 +3521,8 @@ public class NotificationManagerService extends SystemService {
         public int getBubblePreferenceForPackage(String pkg, int uid) {
             enforceSystemOrSystemUIOrSamePackage(pkg,
                     "Caller not system or systemui or same package");
-
-            if (UserHandle.getCallingUserId() != UserHandle.getUserId(uid)) {
+            final int userId = UserHandle.getUserId(uid);
+            if (UserHandle.getCallingUserId() != userId) {
                 getContext().enforceCallingPermission(
                         android.Manifest.permission.INTERACT_ACROSS_USERS,
                         "getBubblePreferenceForPackage for uid " + uid);
@@ -4244,7 +4249,8 @@ public class NotificationManagerService extends SystemService {
                             sbn.getOpPkg(),
                             sbn.getId(), sbn.getTag(), sbn.getUid(), sbn.getInitialPid(),
                             notification,
-                            sbn.getUser(), sbn.getOverrideGroupKey(), sbn.getPostTime());
+                            sbn.getUser(), sbn.getOverrideGroupKey(),
+                            sbn.getPostTime(), sbn.getIsContentSecure());
                 }
             }
             return null;
@@ -5744,6 +5750,8 @@ public class NotificationManagerService extends SystemService {
                             0, appIntent, PendingIntent.FLAG_IMMUTABLE, null,
                             pkg, appInfo.uid);
                 }
+                final boolean isContentSecure = mAppLockManagerService != null &&
+                    mAppLockManagerService.isNotificationSecured(pkg, userId);
                 final StatusBarNotification summarySbn =
                         new StatusBarNotification(adjustedSbn.getPackageName(),
                                 adjustedSbn.getOpPkg(),
@@ -5751,12 +5759,15 @@ public class NotificationManagerService extends SystemService {
                                 GroupHelper.AUTOGROUP_KEY, adjustedSbn.getUid(),
                                 adjustedSbn.getInitialPid(), summaryNotification,
                                 adjustedSbn.getUser(), GroupHelper.AUTOGROUP_KEY,
-                                System.currentTimeMillis());
+                                System.currentTimeMillis(), isContentSecure);
                 summaryRecord = new NotificationRecord(getContext(), summarySbn,
                         notificationRecord.getChannel());
                 summaryRecord.setIsAppImportanceLocked(
                         notificationRecord.getIsAppImportanceLocked());
                 summaries.put(pkg, summarySbn.getKey());
+                summaryRecord.setIsBubbleUpSuppressedByAppLock(
+                    mAppLockManagerService != null &&
+                    mAppLockManagerService.requireUnlock(pkg, userId));
             }
             if (summaryRecord != null && checkDisqualifyingFeatures(userId, MY_UID,
                     summaryRecord.getSbn().getId(), summaryRecord.getSbn().getTag(), summaryRecord,
@@ -6120,6 +6131,27 @@ public class NotificationManagerService extends SystemService {
             sbn.getNotification().flags =
                     (r.mOriginalFlags & ~FLAG_FOREGROUND_SERVICE);
         }
+
+        @Override
+        public void updateSecureNotifications(String pkg, boolean isContentSecure, int userId) {
+            mHandler.post(() -> updateSecureNotificationsInternal(pkg, isContentSecure, userId));
+        }
+
+        private void updateSecureNotificationsInternal(String pkg, boolean isContentSecure, int userId) {
+            synchronized (mNotificationLock) {
+                for (int i = 0; i < mNotificationList.size(); i++) {
+                    final NotificationRecord nr = mNotificationList.get(i);
+                    final StatusBarNotification sbn = nr.getSbn();
+                    if (UserHandle.getUserId(sbn.getUid()) == userId
+                            && sbn.getPackageName().equals(pkg)
+                            && sbn.getIsContentSecure() != isContentSecure) {
+                        sbn.setIsContentSecure(isContentSecure);
+                        mListeners.notifyPostedLocked(nr, nr);
+                    }
+                }
+            }
+            mRankingHandler.requestSort();
+        }
     };
 
     void cancelNotificationInternal(String pkg, String opPkg, int callingUid, int callingPid,
@@ -6230,9 +6262,11 @@ public class NotificationManagerService extends SystemService {
 
         mUsageStats.registerEnqueuedByApp(pkg);
 
+        final boolean isContentSecure = mAppLockManagerService != null &&
+            mAppLockManagerService.isNotificationSecured(pkg, incomingUserId);
         final StatusBarNotification n = new StatusBarNotification(
                 pkg, opPkg, id, tag, notificationUid, callingPid, notification,
-                user, null, System.currentTimeMillis());
+                user, null, System.currentTimeMillis(), isContentSecure);
 
         // setup local book-keeping
         String channelId = notification.getChannelId();
@@ -6272,6 +6306,8 @@ public class NotificationManagerService extends SystemService {
         r.setPostSilently(postSilently);
         r.setFlagBubbleRemoved(false);
         r.setPkgAllowedAsConvo(mMsgPkgsAllowedAsConvos.contains(pkg));
+        r.setIsBubbleUpSuppressedByAppLock(mAppLockManagerService != null &&
+            mAppLockManagerService.requireUnlock(pkg, userId));
 
         if ((notification.flags & Notification.FLAG_FOREGROUND_SERVICE) != 0) {
             final boolean fgServiceShown = channel.isFgServiceShown();
@@ -8106,13 +8142,15 @@ public class NotificationManagerService extends SystemService {
         float mRankingScore;
         boolean mIsConversation;
 
+        boolean mIsBubbleUpSuppressedByAppLock;
+
         NotificationRecordExtractorData(int position, int visibility, boolean showBadge,
                 boolean allowBubble, boolean isBubble, NotificationChannel channel, String groupKey,
                 ArrayList<String> overridePeople, ArrayList<SnoozeCriterion> snoozeCriteria,
                 Integer userSentiment, Integer suppressVisually,
                 ArrayList<Notification.Action> systemSmartActions,
                 ArrayList<CharSequence> smartReplies, int importance, float rankingScore,
-                boolean isConversation) {
+                boolean isConversation, boolean isBubbleUpSuppressedByAppLock) {
             mPosition = position;
             mVisibility = visibility;
             mShowBadge = showBadge;
@@ -8129,6 +8167,7 @@ public class NotificationManagerService extends SystemService {
             mImportance = importance;
             mRankingScore = rankingScore;
             mIsConversation = isConversation;
+            mIsBubbleUpSuppressedByAppLock = isBubbleUpSuppressedByAppLock;
         }
 
         // Returns whether the provided NotificationRecord differs from the cached data in any way.
@@ -8147,7 +8186,8 @@ public class NotificationManagerService extends SystemService {
                     || !Objects.equals(mSuppressVisually, r.getSuppressedVisualEffects())
                     || !Objects.equals(mSystemSmartActions, r.getSystemGeneratedSmartActions())
                     || !Objects.equals(mSmartReplies, r.getSmartReplies())
-                    || mImportance != r.getImportance();
+                    || mImportance != r.getImportance()
+                    || mIsBubbleUpSuppressedByAppLock != r.isBubbleUpSuppressedByAppLock();
         }
 
         // Returns whether the NotificationRecord has a change from this data for which we should
@@ -8198,7 +8238,8 @@ public class NotificationManagerService extends SystemService {
                         r.getSmartReplies(),
                         r.getImportance(),
                         r.getRankingScore(),
-                        r.isConversation());
+                        r.isConversation(),
+                        r.isBubbleUpSuppressedByAppLock());
                 extractorDataBefore.put(r.getKey(), extractorData);
                 mRankingHelper.extractSignals(r);
             }
diff --git a/services/core/java/com/android/server/notification/NotificationRecord.java b/services/core/java/com/android/server/notification/NotificationRecord.java
index b4ca5118e10f..aca157237263 100644
--- a/services/core/java/com/android/server/notification/NotificationRecord.java
+++ b/services/core/java/com/android/server/notification/NotificationRecord.java
@@ -204,6 +204,8 @@ public final class NotificationRecord {
     // are sorted.
     private boolean mPendingLogUpdate = false;
 
+    private boolean mIsBubbleUpSuppressedByAppLock = false;
+
     public NotificationRecord(Context context, StatusBarNotification sbn,
             NotificationChannel channel) {
         this.sbn = sbn;
@@ -1521,6 +1523,14 @@ public final class NotificationRecord {
         return mPendingLogUpdate;
     }
 
+    public void setIsBubbleUpSuppressedByAppLock(boolean suppressed) {
+        mIsBubbleUpSuppressedByAppLock = suppressed;
+    }
+
+    public boolean isBubbleUpSuppressedByAppLock() {
+        return mIsBubbleUpSuppressedByAppLock;
+    }
+
     @VisibleForTesting
     static final class Light {
         public final int color;
diff --git a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java
index 08f3b1a8c6e0..d26139a8b518 100644
--- a/services/core/java/com/android/server/wm/ActivityTaskManagerService.java
+++ b/services/core/java/com/android/server/wm/ActivityTaskManagerService.java
@@ -252,6 +252,7 @@ import com.android.server.am.BaseErrorDialog;
 import com.android.server.am.PendingIntentController;
 import com.android.server.am.PendingIntentRecord;
 import com.android.server.am.UserState;
+import com.android.server.app.AppLockManagerServiceInternal;
 import com.android.server.firewall.IntentFirewall;
 import com.android.server.inputmethod.InputMethodSystemProperty;
 import com.android.server.pm.UserManagerService;
@@ -793,6 +794,8 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
         }
     };
 
+    private AppLockManagerServiceInternal mAppLockManagerService = null;
+
     @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
     public ActivityTaskManagerService(Context context) {
         mContext = context;
@@ -1182,11 +1185,12 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
         assertPackageMatchesCallingUid(callingPackage);
         enforceNotIsolatedCaller("startActivityAsUser");
 
+        final int callingUid = Binder.getCallingUid();
         userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,
-                Binder.getCallingPid(), Binder.getCallingUid(), "startActivityAsUser");
+                Binder.getCallingPid(), callingUid, "startActivityAsUser");
 
-        // TODO: Switch to user app stacks here.
-        return getActivityStartController().obtainStarter(intent, "startActivityAsUser")
+        final ActivityStarter activityStarter = getActivityStartController()
+                .obtainStarter(intent, "startActivityAsUser")
                 .setCaller(caller)
                 .setCallingPackage(callingPackage)
                 .setCallingFeatureId(callingFeatureId)
@@ -1197,8 +1201,22 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
                 .setStartFlags(startFlags)
                 .setProfilerInfo(profilerInfo)
                 .setActivityOptions(bOptions)
-                .setUserId(userId)
-                .execute();
+                .setUserId(userId);
+
+        final ActivityInfo aInfo = resolveActivityInfoForIntent(intent, resolvedType, userId, callingUid);
+        if (aInfo != null) {
+            if (getAppLockManagerService().requireUnlock(aInfo.packageName, mContext.getUserId())) {
+                getAppLockManagerService().unlock(aInfo.packageName, pkg -> {
+                    mContext.getMainExecutor().execute(() -> {
+                        activityStarter.execute();
+                    });
+                }, null /* cancelCallback */, mContext.getUserId());
+                return ActivityManager.START_ABORTED;
+            }
+        }
+
+        // TODO: Switch to user app stacks here.
+        return activityStarter.execute();
 
     }
 
@@ -1716,6 +1734,41 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
 
         final int callingPid = Binder.getCallingPid();
         final int callingUid = Binder.getCallingUid();
+
+        final Task task;
+        synchronized (mGlobalLock) {
+            task = mRootWindowContainer.anyTaskForId(taskId);
+        }
+        final String packageName = getTaskPackageName(task);
+        if (packageName != null) {
+            final int userId = mContext.getUserId();
+            if (getAppLockManagerService().requireUnlock(packageName, userId)) {
+                getAppLockManagerService().unlock(packageName,
+                pkg -> {
+                    mContext.getMainExecutor().execute(() -> {
+                        startActivityFromRecentsInternal(taskId, callingPid,
+                            callingUid, bOptions);
+                    });
+                },
+                pkg -> {
+                    // Send user to recents
+                    getStatusBarManagerInternal().showRecentApps(false);
+                }, userId);
+                return ActivityManager.START_ABORTED;
+            }
+        }
+        return startActivityFromRecentsInternal(taskId, callingPid, callingUid, bOptions);
+    }
+
+    private String getTaskPackageName(Task task) {
+        if (task == null) return null;
+        final Task rootTask = task.getRootTask();
+        if (rootTask == null || rootTask.realActivity == null) return null;
+        return rootTask.realActivity.getPackageName();
+    }
+
+    private int startActivityFromRecentsInternal(int taskId, int callingPid,
+            int callingUid, Bundle bOptions) {
         final SafeActivityOptions safeOptions = SafeActivityOptions.fromBundle(bOptions);
         final long origId = Binder.clearCallingIdentity();
         try {
@@ -3527,6 +3580,11 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
                 return null;
             }
         }
+        final String packageName = getTaskPackageName(task);
+        if (packageName != null && getAppLockManagerService().requireUnlock(
+                packageName, mContext.getUserId())) {
+            return null;
+        }
         // Don't call this while holding the lock as this operation might hit the disk.
         return task.getSnapshot(isLowResolution, restoreFromDisk);
     }
@@ -4822,6 +4880,13 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
         return mStatusBarManagerInternal;
     }
 
+    AppLockManagerServiceInternal getAppLockManagerService() {
+        if (mAppLockManagerService == null) {
+            mAppLockManagerService = LocalServices.getService(AppLockManagerServiceInternal.class);
+        }
+        return mAppLockManagerService;
+    }
+
     AppWarnings getAppWarningsLocked() {
         return mAppWarnings;
     }
@@ -5200,6 +5265,20 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
                 boolean validateIncomingUser, PendingIntentRecord originatingPendingIntent,
                 boolean allowBackgroundActivityStart) {
             assertPackageMatchesCallingUid(callingPackage);
+            final ActivityInfo aInfo = resolveActivityInfoForIntent(intents[0], resolvedTypes[0], userId,
+                realCallingUid);
+            if (aInfo != null) {
+                if (getAppLockManagerService().requireUnlock(aInfo.packageName, mContext.getUserId())) {
+                    getAppLockManagerService().unlock(aInfo.packageName, pkg -> {
+                        mContext.getMainExecutor().execute(() ->
+                            getActivityStartController().startActivitiesInPackage(uid, realCallingPid,
+                                realCallingUid, callingPackage, callingFeatureId, intents, resolvedTypes,
+                                resultTo, options, userId, validateIncomingUser, originatingPendingIntent,
+                                allowBackgroundActivityStart));
+                    }, null /* cancelCallback */, mContext.getUserId());
+                    return ActivityManager.START_ABORTED;
+                }
+            }
             return getActivityStartController().startActivitiesInPackage(uid, realCallingPid,
                     realCallingUid, callingPackage, callingFeatureId, intents, resolvedTypes,
                     resultTo, options, userId, validateIncomingUser, originatingPendingIntent,
@@ -5214,6 +5293,21 @@ public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
                 boolean validateIncomingUser, PendingIntentRecord originatingPendingIntent,
                 boolean allowBackgroundActivityStart) {
             assertPackageMatchesCallingUid(callingPackage);
+            final ActivityInfo aInfo = resolveActivityInfoForIntent(intent, resolvedType, userId,
+                realCallingUid);
+            if (aInfo != null) {
+                if (getAppLockManagerService().requireUnlock(aInfo.packageName, mContext.getUserId())) {
+                    getAppLockManagerService().unlock(aInfo.packageName, pkg -> {
+                        mContext.getMainExecutor().execute(() ->
+                            getActivityStartController().startActivityInPackage(uid, realCallingPid,
+                                realCallingUid, callingPackage, callingFeatureId, intent, resolvedType,
+                                resultTo, resultWho, requestCode, startFlags, options, userId, inTask,
+                                reason, validateIncomingUser, originatingPendingIntent,
+                                allowBackgroundActivityStart));
+                    }, null /* cancelCallback */, mContext.getUserId());
+                    return ActivityManager.START_ABORTED;
+                }
+            }
             return getActivityStartController().startActivityInPackage(uid, realCallingPid,
                     realCallingUid, callingPackage, callingFeatureId, intent, resolvedType,
                     resultTo, resultWho, requestCode, startFlags, options, userId, inTask,
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index 33e32393090e..81d87272eca9 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -385,6 +385,9 @@ public final class SystemServer implements Dumpable {
 
     private static final String TETHERING_CONNECTOR_CLASS = "android.net.ITetheringConnector";
 
+    private static final String APP_LOCK_SERVICE_CLASS =
+            "com.android.server.app.AppLockManagerService$Lifecycle";
+
     private static final String PERSISTENT_DATA_BLOCK_PROP = "ro.frp.pst";
 
     private static final String UNCRYPT_PACKAGE_FILE = "/cache/recovery/uncrypt_file";
@@ -2634,6 +2637,10 @@ public final class SystemServer implements Dumpable {
             t.traceEnd();
         }
 
+        t.traceBegin("AppLockManagerService");
+        mSystemServiceManager.startService(APP_LOCK_SERVICE_CLASS);
+        t.traceEnd();
+
         t.traceBegin("StartBootPhaseDeviceSpecificServicesReady");
         mSystemServiceManager.startBootPhase(t, SystemService.PHASE_DEVICE_SPECIFIC_SERVICES_READY);
         t.traceEnd();
-- 
2.32.0 (Apple Git-132)

